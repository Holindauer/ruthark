/* automatically generated by rust-bindgen 0.60.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const CUDA_VERSION: u32 = 11070;
pub const CU_IPC_HANDLE_SIZE: u32 = 64;
pub const CU_MEMHOSTALLOC_PORTABLE: u32 = 1;
pub const CU_MEMHOSTALLOC_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTALLOC_WRITECOMBINED: u32 = 4;
pub const CU_MEMHOSTREGISTER_PORTABLE: u32 = 1;
pub const CU_MEMHOSTREGISTER_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTREGISTER_IOMEMORY: u32 = 4;
pub const CU_MEMHOSTREGISTER_READ_ONLY: u32 = 8;
pub const CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL: u32 = 1;
pub const CUDA_EXTERNAL_MEMORY_DEDICATED: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC: u32 = 2;
pub const CUDA_NVSCISYNC_ATTR_SIGNAL: u32 = 1;
pub const CUDA_NVSCISYNC_ATTR_WAIT: u32 = 2;
pub const CU_MEM_CREATE_USAGE_TILE_POOL: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: u32 = 2;
pub const CUDA_ARRAY3D_LAYERED: u32 = 1;
pub const CUDA_ARRAY3D_2DARRAY: u32 = 1;
pub const CUDA_ARRAY3D_SURFACE_LDST: u32 = 2;
pub const CUDA_ARRAY3D_CUBEMAP: u32 = 4;
pub const CUDA_ARRAY3D_TEXTURE_GATHER: u32 = 8;
pub const CUDA_ARRAY3D_DEPTH_TEXTURE: u32 = 16;
pub const CUDA_ARRAY3D_COLOR_ATTACHMENT: u32 = 32;
pub const CUDA_ARRAY3D_SPARSE: u32 = 64;
pub const CUDA_ARRAY3D_DEFERRED_MAPPING: u32 = 128;
pub const CU_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const CU_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const CU_TRSF_SRGB: u32 = 16;
pub const CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION: u32 = 32;
pub const CU_TRSF_SEAMLESS_CUBEMAP: u32 = 64;
pub const CU_LAUNCH_PARAM_END_AS_INT: u32 = 0;
pub const CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT: u32 = 1;
pub const CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT: u32 = 2;
pub const CU_PARAM_TR_DEFAULT: i32 = -1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const cudaHostAllocDefault: u32 = 0;
pub const cudaHostAllocPortable: u32 = 1;
pub const cudaHostAllocMapped: u32 = 2;
pub const cudaHostAllocWriteCombined: u32 = 4;
pub const cudaHostRegisterDefault: u32 = 0;
pub const cudaHostRegisterPortable: u32 = 1;
pub const cudaHostRegisterMapped: u32 = 2;
pub const cudaHostRegisterIoMemory: u32 = 4;
pub const cudaHostRegisterReadOnly: u32 = 8;
pub const cudaPeerAccessDefault: u32 = 0;
pub const cudaStreamDefault: u32 = 0;
pub const cudaStreamNonBlocking: u32 = 1;
pub const cudaEventDefault: u32 = 0;
pub const cudaEventBlockingSync: u32 = 1;
pub const cudaEventDisableTiming: u32 = 2;
pub const cudaEventInterprocess: u32 = 4;
pub const cudaEventRecordDefault: u32 = 0;
pub const cudaEventRecordExternal: u32 = 1;
pub const cudaEventWaitDefault: u32 = 0;
pub const cudaEventWaitExternal: u32 = 1;
pub const cudaDeviceScheduleAuto: u32 = 0;
pub const cudaDeviceScheduleSpin: u32 = 1;
pub const cudaDeviceScheduleYield: u32 = 2;
pub const cudaDeviceScheduleBlockingSync: u32 = 4;
pub const cudaDeviceBlockingSync: u32 = 4;
pub const cudaDeviceScheduleMask: u32 = 7;
pub const cudaDeviceMapHost: u32 = 8;
pub const cudaDeviceLmemResizeToMax: u32 = 16;
pub const cudaDeviceMask: u32 = 31;
pub const cudaArrayDefault: u32 = 0;
pub const cudaArrayLayered: u32 = 1;
pub const cudaArraySurfaceLoadStore: u32 = 2;
pub const cudaArrayCubemap: u32 = 4;
pub const cudaArrayTextureGather: u32 = 8;
pub const cudaArrayColorAttachment: u32 = 32;
pub const cudaArraySparse: u32 = 64;
pub const cudaArrayDeferredMapping: u32 = 128;
pub const cudaIpcMemLazyEnablePeerAccess: u32 = 1;
pub const cudaMemAttachGlobal: u32 = 1;
pub const cudaMemAttachHost: u32 = 2;
pub const cudaMemAttachSingle: u32 = 4;
pub const cudaOccupancyDefault: u32 = 0;
pub const cudaOccupancyDisableCachingOverride: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const cudaCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const cudaArraySparsePropertiesSingleMipTail: u32 = 1;
pub const CUDA_IPC_HANDLE_SIZE: u32 = 64;
pub const cudaExternalMemoryDedicated: u32 = 1;
pub const cudaExternalSemaphoreSignalSkipNvSciBufMemSync: u32 = 1;
pub const cudaExternalSemaphoreWaitSkipNvSciBufMemSync: u32 = 2;
pub const cudaNvSciSyncAttrSignal: u32 = 1;
pub const cudaNvSciSyncAttrWait: u32 = 2;
pub const cudaSurfaceType1D: u32 = 1;
pub const cudaSurfaceType2D: u32 = 2;
pub const cudaSurfaceType3D: u32 = 3;
pub const cudaSurfaceTypeCubemap: u32 = 12;
pub const cudaSurfaceType1DLayered: u32 = 241;
pub const cudaSurfaceType2DLayered: u32 = 242;
pub const cudaSurfaceTypeCubemapLayered: u32 = 252;
pub const cudaTextureType1D: u32 = 1;
pub const cudaTextureType2D: u32 = 2;
pub const cudaTextureType3D: u32 = 3;
pub const cudaTextureTypeCubemap: u32 = 12;
pub const cudaTextureType1DLayered: u32 = 241;
pub const cudaTextureType2DLayered: u32 = 242;
pub const cudaTextureTypeCubemapLayered: u32 = 252;
pub const CUDART_VERSION: u32 = 11070;
pub const __CUDART_API_VERSION: u32 = 11070;
pub const FUTHARK_SUCCESS: u32 = 0;
pub const FUTHARK_PROGRAM_ERROR: u32 = 2;
pub const FUTHARK_OUT_OF_MEMORY: u32 = 3;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    test_field___clang_max_align_nonce2();
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    fn test_field___wch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
    }
    test_field___wch();
    fn test_field___wchb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    test_field___wchb();
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    test_field___value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field__codecvt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
    }
    test_field__codecvt();
    fn test_field__wide_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
    }
    test_field__wide_data();
    fn test_field__freeres_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
    }
    test_field__freeres_list();
    fn test_field__freeres_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
    }
    test_field__freeres_buf();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field___fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(__fds_bits)
            )
        );
    }
    test_field___fds_bits();
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    fn test_field___value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value64)
            )
        );
    }
    test_field___value64();
    fn test_field___value32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value32)
            )
        );
    }
    test_field___value32();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_slist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_slist),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    fn test_field___readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
    }
    test_field___readers();
    fn test_field___writers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
    }
    test_field___writers();
    fn test_field___wrphase_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
    }
    test_field___wrphase_futex();
    fn test_field___writers_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
    }
    test_field___writers_futex();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___cur_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
    }
    test_field___cur_writer();
    fn test_field___shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
    }
    test_field___shared();
    fn test_field___rwelision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__rwelision)
            )
        );
    }
    test_field___rwelision();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    test_field___flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__once_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__once_flag),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    fn test_field_fptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(fptr)
            )
        );
    }
    test_field_fptr();
    fn test_field_rptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rptr)
            )
        );
    }
    test_field_rptr();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_rand_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_type)
            )
        );
    }
    test_field_rand_type();
    fn test_field_rand_deg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_deg)
            )
        );
    }
    test_field_rand_deg();
    fn test_field_rand_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_sep)
            )
        );
    }
    test_field_rand_sep();
    fn test_field_end_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(end_ptr)
            )
        );
    }
    test_field_end_ptr();
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___old_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__old_x)
            )
        );
    }
    test_field___old_x();
    fn test_field___c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__c)
            )
        );
    }
    test_field___c();
    fn test_field___init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__init)
            )
        );
    }
    test_field___init();
    fn test_field___a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<drand48_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(drand48_data),
                "::",
                stringify!(__a)
            )
        );
    }
    test_field___a();
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: size_t);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type cuuint32_t = u32;
pub type cuuint64_t = u64;
pub type CUdeviceptr_v2 = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUtexObject = CUtexObject_v1;
pub type CUsurfObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUsurfObject = CUsurfObject_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type CUmemoryPool = *mut CUmemPoolHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type CUuserObject = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    fn test_field_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUuuid_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUuuid_st),
                "::",
                stringify!(bytes)
            )
        );
    }
    test_field_bytes();
}
pub type CUuuid = CUuuid_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUipcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcEventHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUipcEventHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUipcEventHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUipcEventHandle_v1 = CUipcEventHandle_st;
pub type CUipcEventHandle = CUipcEventHandle_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUipcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<CUipcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcMemHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUipcMemHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUipcMemHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUipcMemHandle_v1 = CUipcMemHandle_st;
pub type CUipcMemHandle = CUipcMemHandle_v1;
pub const CUipcMem_flags_enum_CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS: CUipcMem_flags_enum = 1;
pub type CUipcMem_flags_enum = ::std::os::raw::c_uint;
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_GLOBAL: CUmemAttach_flags_enum = 1;
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_HOST: CUmemAttach_flags_enum = 2;
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_SINGLE: CUmemAttach_flags_enum = 4;
pub type CUmemAttach_flags_enum = ::std::os::raw::c_uint;
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
pub const CUctx_flags_enum_CU_CTX_SCHED_AUTO: CUctx_flags_enum = 0;
pub const CUctx_flags_enum_CU_CTX_SCHED_SPIN: CUctx_flags_enum = 1;
pub const CUctx_flags_enum_CU_CTX_SCHED_YIELD: CUctx_flags_enum = 2;
pub const CUctx_flags_enum_CU_CTX_SCHED_BLOCKING_SYNC: CUctx_flags_enum = 4;
pub const CUctx_flags_enum_CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = 4;
pub const CUctx_flags_enum_CU_CTX_SCHED_MASK: CUctx_flags_enum = 7;
pub const CUctx_flags_enum_CU_CTX_MAP_HOST: CUctx_flags_enum = 8;
pub const CUctx_flags_enum_CU_CTX_LMEM_RESIZE_TO_MAX: CUctx_flags_enum = 16;
pub const CUctx_flags_enum_CU_CTX_FLAGS_MASK: CUctx_flags_enum = 31;
pub type CUctx_flags_enum = ::std::os::raw::c_uint;
pub use self::CUctx_flags_enum as CUctx_flags;
pub const CUstream_flags_enum_CU_STREAM_DEFAULT: CUstream_flags_enum = 0;
pub const CUstream_flags_enum_CU_STREAM_NON_BLOCKING: CUstream_flags_enum = 1;
pub type CUstream_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstream_flags_enum as CUstream_flags;
pub const CUevent_flags_enum_CU_EVENT_DEFAULT: CUevent_flags_enum = 0;
pub const CUevent_flags_enum_CU_EVENT_BLOCKING_SYNC: CUevent_flags_enum = 1;
pub const CUevent_flags_enum_CU_EVENT_DISABLE_TIMING: CUevent_flags_enum = 2;
pub const CUevent_flags_enum_CU_EVENT_INTERPROCESS: CUevent_flags_enum = 4;
pub type CUevent_flags_enum = ::std::os::raw::c_uint;
pub use self::CUevent_flags_enum as CUevent_flags;
pub const CUevent_record_flags_enum_CU_EVENT_RECORD_DEFAULT: CUevent_record_flags_enum = 0;
pub const CUevent_record_flags_enum_CU_EVENT_RECORD_EXTERNAL: CUevent_record_flags_enum = 1;
pub type CUevent_record_flags_enum = ::std::os::raw::c_uint;
pub use self::CUevent_record_flags_enum as CUevent_record_flags;
pub const CUevent_wait_flags_enum_CU_EVENT_WAIT_DEFAULT: CUevent_wait_flags_enum = 0;
pub const CUevent_wait_flags_enum_CU_EVENT_WAIT_EXTERNAL: CUevent_wait_flags_enum = 1;
pub type CUevent_wait_flags_enum = ::std::os::raw::c_uint;
pub use self::CUevent_wait_flags_enum as CUevent_wait_flags;
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_GEQ: CUstreamWaitValue_flags_enum = 0;
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_EQ: CUstreamWaitValue_flags_enum = 1;
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_AND: CUstreamWaitValue_flags_enum = 2;
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_NOR: CUstreamWaitValue_flags_enum = 3;
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_FLUSH: CUstreamWaitValue_flags_enum =
    1073741824;
pub type CUstreamWaitValue_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
pub const CUstreamWriteValue_flags_enum_CU_STREAM_WRITE_VALUE_DEFAULT:
    CUstreamWriteValue_flags_enum = 0;
pub const CUstreamWriteValue_flags_enum_CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER:
    CUstreamWriteValue_flags_enum = 1;
pub type CUstreamWriteValue_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WAIT_VALUE_32: CUstreamBatchMemOpType_enum =
    1;
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WRITE_VALUE_32: CUstreamBatchMemOpType_enum =
    2;
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WAIT_VALUE_64: CUstreamBatchMemOpType_enum =
    4;
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WRITE_VALUE_64: CUstreamBatchMemOpType_enum =
    5;
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_BARRIER: CUstreamBatchMemOpType_enum = 6;
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES:
    CUstreamBatchMemOpType_enum = 3;
pub type CUstreamBatchMemOpType_enum = ::std::os::raw::c_uint;
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
pub const CUstreamMemoryBarrier_flags_enum_CU_STREAM_MEMORY_BARRIER_TYPE_SYS:
    CUstreamMemoryBarrier_flags_enum = 0;
pub const CUstreamMemoryBarrier_flags_enum_CU_STREAM_MEMORY_BARRIER_TYPE_GPU:
    CUstreamMemoryBarrier_flags_enum = 1;
pub type CUstreamMemoryBarrier_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamMemoryBarrier_flags_enum as CUstreamMemoryBarrier_flags;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union {
    pub operation: CUstreamBatchMemOpType,
    pub waitValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    pub writeValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    pub flushRemoteWrites: CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    pub memoryBarrier: CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
    pub pad: [cuuint64_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
                ),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
                ),
                "::",
                stringify!(value64)
            )
        );
    }
    test_field_value64();
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_alias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
                "::",
                stringify!(alias)
            )
        );
    }
    test_field_alias();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
                ),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
                ),
                "::",
                stringify!(value64)
            )
        );
    }
    test_field_value64();
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_alias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
                "::",
                stringify!(alias)
            )
        );
    }
    test_field_alias();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st)
        )
    );
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamBatchMemOpParams_union))
    );
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamBatchMemOpParams_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_waitValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamBatchMemOpParams_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union),
                "::",
                stringify!(waitValue)
            )
        );
    }
    test_field_waitValue();
    fn test_field_writeValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamBatchMemOpParams_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).writeValue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union),
                "::",
                stringify!(writeValue)
            )
        );
    }
    test_field_writeValue();
    fn test_field_flushRemoteWrites() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamBatchMemOpParams_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flushRemoteWrites) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union),
                "::",
                stringify!(flushRemoteWrites)
            )
        );
    }
    test_field_flushRemoteWrites();
    fn test_field_memoryBarrier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamBatchMemOpParams_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryBarrier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union),
                "::",
                stringify!(memoryBarrier)
            )
        );
    }
    test_field_memoryBarrier();
    fn test_field_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamBatchMemOpParams_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamBatchMemOpParams_union),
                "::",
                stringify!(pad)
            )
        );
    }
    test_field_pad();
}
pub type CUstreamBatchMemOpParams_v1 = CUstreamBatchMemOpParams_union;
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_BATCH_MEM_OP_NODE_PARAMS_st {
    pub ctx: CUcontext,
    pub count: ::std::os::raw::c_uint,
    pub paramArray: *mut CUstreamBatchMemOpParams,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_BATCH_MEM_OP_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st)
        )
    );
    fn test_field_ctx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
                "::",
                stringify!(ctx)
            )
        );
    }
    test_field_ctx();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_paramArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramArray) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
                "::",
                stringify!(paramArray)
            )
        );
    }
    test_field_paramArray();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS = CUDA_BATCH_MEM_OP_NODE_PARAMS_st;
pub const CUoccupancy_flags_enum_CU_OCCUPANCY_DEFAULT: CUoccupancy_flags_enum = 0;
pub const CUoccupancy_flags_enum_CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE: CUoccupancy_flags_enum = 1;
pub type CUoccupancy_flags_enum = ::std::os::raw::c_uint;
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
pub const CUstreamUpdateCaptureDependencies_flags_enum_CU_STREAM_ADD_CAPTURE_DEPENDENCIES:
    CUstreamUpdateCaptureDependencies_flags_enum = 0;
pub const CUstreamUpdateCaptureDependencies_flags_enum_CU_STREAM_SET_CAPTURE_DEPENDENCIES:
    CUstreamUpdateCaptureDependencies_flags_enum = 1;
pub type CUstreamUpdateCaptureDependencies_flags_enum = ::std::os::raw::c_uint;
pub use self::CUstreamUpdateCaptureDependencies_flags_enum as CUstreamUpdateCaptureDependencies_flags;
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT8: CUarray_format_enum = 1;
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT16: CUarray_format_enum = 2;
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT32: CUarray_format_enum = 3;
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT8: CUarray_format_enum = 8;
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT16: CUarray_format_enum = 9;
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT32: CUarray_format_enum = 10;
pub const CUarray_format_enum_CU_AD_FORMAT_HALF: CUarray_format_enum = 16;
pub const CUarray_format_enum_CU_AD_FORMAT_FLOAT: CUarray_format_enum = 32;
pub const CUarray_format_enum_CU_AD_FORMAT_NV12: CUarray_format_enum = 176;
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT8X1: CUarray_format_enum = 192;
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT8X2: CUarray_format_enum = 193;
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT8X4: CUarray_format_enum = 194;
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT16X1: CUarray_format_enum = 195;
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT16X2: CUarray_format_enum = 196;
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT16X4: CUarray_format_enum = 197;
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT8X1: CUarray_format_enum = 198;
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT8X2: CUarray_format_enum = 199;
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT8X4: CUarray_format_enum = 200;
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT16X1: CUarray_format_enum = 201;
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT16X2: CUarray_format_enum = 202;
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT16X4: CUarray_format_enum = 203;
pub const CUarray_format_enum_CU_AD_FORMAT_BC1_UNORM: CUarray_format_enum = 145;
pub const CUarray_format_enum_CU_AD_FORMAT_BC1_UNORM_SRGB: CUarray_format_enum = 146;
pub const CUarray_format_enum_CU_AD_FORMAT_BC2_UNORM: CUarray_format_enum = 147;
pub const CUarray_format_enum_CU_AD_FORMAT_BC2_UNORM_SRGB: CUarray_format_enum = 148;
pub const CUarray_format_enum_CU_AD_FORMAT_BC3_UNORM: CUarray_format_enum = 149;
pub const CUarray_format_enum_CU_AD_FORMAT_BC3_UNORM_SRGB: CUarray_format_enum = 150;
pub const CUarray_format_enum_CU_AD_FORMAT_BC4_UNORM: CUarray_format_enum = 151;
pub const CUarray_format_enum_CU_AD_FORMAT_BC4_SNORM: CUarray_format_enum = 152;
pub const CUarray_format_enum_CU_AD_FORMAT_BC5_UNORM: CUarray_format_enum = 153;
pub const CUarray_format_enum_CU_AD_FORMAT_BC5_SNORM: CUarray_format_enum = 154;
pub const CUarray_format_enum_CU_AD_FORMAT_BC6H_UF16: CUarray_format_enum = 155;
pub const CUarray_format_enum_CU_AD_FORMAT_BC6H_SF16: CUarray_format_enum = 156;
pub const CUarray_format_enum_CU_AD_FORMAT_BC7_UNORM: CUarray_format_enum = 157;
pub const CUarray_format_enum_CU_AD_FORMAT_BC7_UNORM_SRGB: CUarray_format_enum = 158;
pub type CUarray_format_enum = ::std::os::raw::c_uint;
pub use self::CUarray_format_enum as CUarray_format;
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_WRAP: CUaddress_mode_enum = 0;
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_CLAMP: CUaddress_mode_enum = 1;
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_MIRROR: CUaddress_mode_enum = 2;
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_BORDER: CUaddress_mode_enum = 3;
pub type CUaddress_mode_enum = ::std::os::raw::c_uint;
pub use self::CUaddress_mode_enum as CUaddress_mode;
pub const CUfilter_mode_enum_CU_TR_FILTER_MODE_POINT: CUfilter_mode_enum = 0;
pub const CUfilter_mode_enum_CU_TR_FILTER_MODE_LINEAR: CUfilter_mode_enum = 1;
pub type CUfilter_mode_enum = ::std::os::raw::c_uint;
pub use self::CUfilter_mode_enum as CUfilter_mode;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
    CUdevice_attribute_enum = 1;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: CUdevice_attribute_enum = 2;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: CUdevice_attribute_enum = 3;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: CUdevice_attribute_enum = 4;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: CUdevice_attribute_enum = 5;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: CUdevice_attribute_enum = 6;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: CUdevice_attribute_enum = 7;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 8;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 8;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY:
    CUdevice_attribute_enum = 9;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_WARP_SIZE: CUdevice_attribute_enum = 10;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_PITCH: CUdevice_attribute_enum = 11;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK:
    CUdevice_attribute_enum = 12;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
    12;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CLOCK_RATE: CUdevice_attribute_enum = 13;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: CUdevice_attribute_enum =
    14;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: CUdevice_attribute_enum = 15;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT:
    CUdevice_attribute_enum = 16;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: CUdevice_attribute_enum =
    17;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_INTEGRATED: CUdevice_attribute_enum = 18;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: CUdevice_attribute_enum =
    19;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: CUdevice_attribute_enum = 20;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH:
    CUdevice_attribute_enum = 21;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH:
    CUdevice_attribute_enum = 22;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT:
    CUdevice_attribute_enum = 23;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH:
    CUdevice_attribute_enum = 24;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT:
    CUdevice_attribute_enum = 25;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH:
    CUdevice_attribute_enum = 26;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 27;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:
    CUdevice_attribute_enum = 28;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 29;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH:
    CUdevice_attribute_enum = 27;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT:
    CUdevice_attribute_enum = 28;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES:
    CUdevice_attribute_enum = 29;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT: CUdevice_attribute_enum =
    30;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: CUdevice_attribute_enum =
    31;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_ECC_ENABLED: CUdevice_attribute_enum = 32;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: CUdevice_attribute_enum = 33;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: CUdevice_attribute_enum = 34;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TCC_DRIVER: CUdevice_attribute_enum = 35;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: CUdevice_attribute_enum =
    36;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH:
    CUdevice_attribute_enum = 37;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: CUdevice_attribute_enum = 38;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 39;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT: CUdevice_attribute_enum =
    40;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: CUdevice_attribute_enum =
    41;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 42;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 43;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER: CUdevice_attribute_enum =
    44;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH:
    CUdevice_attribute_enum = 45;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT:
    CUdevice_attribute_enum = 46;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE:
    CUdevice_attribute_enum = 47;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE:
    CUdevice_attribute_enum = 48;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE:
    CUdevice_attribute_enum = 49;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: CUdevice_attribute_enum = 50;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT:
    CUdevice_attribute_enum = 51;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH:
    CUdevice_attribute_enum = 52;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH:
    CUdevice_attribute_enum = 53;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS:
    CUdevice_attribute_enum = 54;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH:
    CUdevice_attribute_enum = 55;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH:
    CUdevice_attribute_enum = 56;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT:
    CUdevice_attribute_enum = 57;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH:
    CUdevice_attribute_enum = 58;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT:
    CUdevice_attribute_enum = 59;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH:
    CUdevice_attribute_enum = 60;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 61;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 62;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 63;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT:
    CUdevice_attribute_enum = 64;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 65;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH:
    CUdevice_attribute_enum = 66;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH:
    CUdevice_attribute_enum = 67;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS:
    CUdevice_attribute_enum = 68;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH:
    CUdevice_attribute_enum = 69;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH:
    CUdevice_attribute_enum = 70;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT:
    CUdevice_attribute_enum = 71;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH:
    CUdevice_attribute_enum = 72;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH:
    CUdevice_attribute_enum = 73;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT:
    CUdevice_attribute_enum = 74;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR:
    CUdevice_attribute_enum = 75;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR:
    CUdevice_attribute_enum = 76;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH:
    CUdevice_attribute_enum = 77;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED:
    CUdevice_attribute_enum = 78;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED:
    CUdevice_attribute_enum = 79;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED:
    CUdevice_attribute_enum = 80;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 81;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 82;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: CUdevice_attribute_enum = 83;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: CUdevice_attribute_enum = 84;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID:
    CUdevice_attribute_enum = 85;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED:
    CUdevice_attribute_enum = 86;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO:
    CUdevice_attribute_enum = 87;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS:
    CUdevice_attribute_enum = 88;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS:
    CUdevice_attribute_enum = 89;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED:
    CUdevice_attribute_enum = 90;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM:
    CUdevice_attribute_enum = 91;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS:
    CUdevice_attribute_enum = 92;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS:
    CUdevice_attribute_enum = 93;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR:
    CUdevice_attribute_enum = 94;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH: CUdevice_attribute_enum =
    95;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH:
    CUdevice_attribute_enum = 96;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN:
    CUdevice_attribute_enum = 97;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES:
    CUdevice_attribute_enum = 98;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED:
    CUdevice_attribute_enum = 99;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES : CUdevice_attribute_enum = 100 ;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST:
    CUdevice_attribute_enum = 101;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 102;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 102;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED : CUdevice_attribute_enum = 103 ;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED:
    CUdevice_attribute_enum = 104;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED:
    CUdevice_attribute_enum = 105;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 106;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED:
    CUdevice_attribute_enum = 107;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE:
    CUdevice_attribute_enum = 108;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE:
    CUdevice_attribute_enum = 109;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED:
    CUdevice_attribute_enum = 110;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 111;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED:
    CUdevice_attribute_enum = 112;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED:
    CUdevice_attribute_enum = 113;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED:
    CUdevice_attribute_enum = 114;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED:
    CUdevice_attribute_enum = 115;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED:
    CUdevice_attribute_enum = 116;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS:
    CUdevice_attribute_enum = 117;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING:
    CUdevice_attribute_enum = 118;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES:
    CUdevice_attribute_enum = 119;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED:
    CUdevice_attribute_enum = 121;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2:
    CUdevice_attribute_enum = 122;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2:
    CUdevice_attribute_enum = 123;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED: CUdevice_attribute_enum =
    124;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX: CUdevice_attribute_enum = 125;
pub type CUdevice_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUdevprop_st {
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    pub sharedMemPerBlock: ::std::os::raw::c_int,
    pub totalConstantMemory: ::std::os::raw::c_int,
    pub SIMDWidth: ::std::os::raw::c_int,
    pub memPitch: ::std::os::raw::c_int,
    pub regsPerBlock: ::std::os::raw::c_int,
    pub clockRate: ::std::os::raw::c_int,
    pub textureAlign: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUdevprop_st() {
    assert_eq!(
        ::std::mem::size_of::<CUdevprop_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUdevprop_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUdevprop_st))
    );
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_maxThreadsDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(maxThreadsDim)
            )
        );
    }
    test_field_maxThreadsDim();
    fn test_field_maxGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(maxGridSize)
            )
        );
    }
    test_field_maxGridSize();
    fn test_field_sharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(sharedMemPerBlock)
            )
        );
    }
    test_field_sharedMemPerBlock();
    fn test_field_totalConstantMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalConstantMemory) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(totalConstantMemory)
            )
        );
    }
    test_field_totalConstantMemory();
    fn test_field_SIMDWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SIMDWidth) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(SIMDWidth)
            )
        );
    }
    test_field_SIMDWidth();
    fn test_field_memPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(memPitch)
            )
        );
    }
    test_field_memPitch();
    fn test_field_regsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(regsPerBlock)
            )
        );
    }
    test_field_regsPerBlock();
    fn test_field_clockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(clockRate)
            )
        );
    }
    test_field_clockRate();
    fn test_field_textureAlign() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUdevprop_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureAlign) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(CUdevprop_st),
                "::",
                stringify!(textureAlign)
            )
        );
    }
    test_field_textureAlign();
}
pub type CUdevprop_v1 = CUdevprop_st;
pub type CUdevprop = CUdevprop_v1;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_CONTEXT: CUpointer_attribute_enum = 1;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMORY_TYPE: CUpointer_attribute_enum = 2;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_DEVICE_POINTER: CUpointer_attribute_enum =
    3;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_HOST_POINTER: CUpointer_attribute_enum = 4;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_P2P_TOKENS: CUpointer_attribute_enum = 5;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_SYNC_MEMOPS: CUpointer_attribute_enum = 6;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_BUFFER_ID: CUpointer_attribute_enum = 7;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_MANAGED: CUpointer_attribute_enum = 8;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL: CUpointer_attribute_enum =
    9;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE:
    CUpointer_attribute_enum = 10;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_RANGE_START_ADDR: CUpointer_attribute_enum =
    11;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_RANGE_SIZE: CUpointer_attribute_enum = 12;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPED: CUpointer_attribute_enum = 13;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES:
    CUpointer_attribute_enum = 14;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE:
    CUpointer_attribute_enum = 15;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAGS: CUpointer_attribute_enum = 16;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE: CUpointer_attribute_enum =
    17;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPING_SIZE: CUpointer_attribute_enum = 18;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR:
    CUpointer_attribute_enum = 19;
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID: CUpointer_attribute_enum =
    20;
pub type CUpointer_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
    CUfunction_attribute_enum = 0;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: CUfunction_attribute_enum =
    1;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: CUfunction_attribute_enum =
    2;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: CUfunction_attribute_enum =
    3;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_NUM_REGS: CUfunction_attribute_enum = 4;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_PTX_VERSION: CUfunction_attribute_enum = 5;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_BINARY_VERSION: CUfunction_attribute_enum = 6;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CACHE_MODE_CA: CUfunction_attribute_enum = 7;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES:
    CUfunction_attribute_enum = 8;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT:
    CUfunction_attribute_enum = 9;
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX: CUfunction_attribute_enum = 10;
pub type CUfunction_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_NONE: CUfunc_cache_enum = 0;
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_SHARED: CUfunc_cache_enum = 1;
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_L1: CUfunc_cache_enum = 2;
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_EQUAL: CUfunc_cache_enum = 3;
pub type CUfunc_cache_enum = ::std::os::raw::c_uint;
pub use self::CUfunc_cache_enum as CUfunc_cache;
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: CUsharedconfig_enum = 0;
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: CUsharedconfig_enum = 1;
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: CUsharedconfig_enum = 2;
pub type CUsharedconfig_enum = ::std::os::raw::c_uint;
pub use self::CUsharedconfig_enum as CUsharedconfig;
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_DEFAULT: CUshared_carveout_enum = -1;
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_MAX_SHARED: CUshared_carveout_enum = 100;
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_MAX_L1: CUshared_carveout_enum = 0;
pub type CUshared_carveout_enum = ::std::os::raw::c_int;
pub use self::CUshared_carveout_enum as CUshared_carveout;
pub const CUmemorytype_enum_CU_MEMORYTYPE_HOST: CUmemorytype_enum = 1;
pub const CUmemorytype_enum_CU_MEMORYTYPE_DEVICE: CUmemorytype_enum = 2;
pub const CUmemorytype_enum_CU_MEMORYTYPE_ARRAY: CUmemorytype_enum = 3;
pub const CUmemorytype_enum_CU_MEMORYTYPE_UNIFIED: CUmemorytype_enum = 4;
pub type CUmemorytype_enum = ::std::os::raw::c_uint;
pub use self::CUmemorytype_enum as CUmemorytype;
pub const CUcomputemode_enum_CU_COMPUTEMODE_DEFAULT: CUcomputemode_enum = 0;
pub const CUcomputemode_enum_CU_COMPUTEMODE_PROHIBITED: CUcomputemode_enum = 2;
pub const CUcomputemode_enum_CU_COMPUTEMODE_EXCLUSIVE_PROCESS: CUcomputemode_enum = 3;
pub type CUcomputemode_enum = ::std::os::raw::c_uint;
pub use self::CUcomputemode_enum as CUcomputemode;
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_READ_MOSTLY: CUmem_advise_enum = 1;
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_READ_MOSTLY: CUmem_advise_enum = 2;
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_PREFERRED_LOCATION: CUmem_advise_enum = 3;
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION: CUmem_advise_enum = 4;
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_ACCESSED_BY: CUmem_advise_enum = 5;
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_ACCESSED_BY: CUmem_advise_enum = 6;
pub type CUmem_advise_enum = ::std::os::raw::c_uint;
pub use self::CUmem_advise_enum as CUmem_advise;
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY:
    CUmem_range_attribute_enum = 1;
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION:
    CUmem_range_attribute_enum = 2;
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY:
    CUmem_range_attribute_enum = 3;
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION:
    CUmem_range_attribute_enum = 4;
pub type CUmem_range_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
pub const CUjit_option_enum_CU_JIT_MAX_REGISTERS: CUjit_option_enum = 0;
pub const CUjit_option_enum_CU_JIT_THREADS_PER_BLOCK: CUjit_option_enum = 1;
pub const CUjit_option_enum_CU_JIT_WALL_TIME: CUjit_option_enum = 2;
pub const CUjit_option_enum_CU_JIT_INFO_LOG_BUFFER: CUjit_option_enum = 3;
pub const CUjit_option_enum_CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES: CUjit_option_enum = 4;
pub const CUjit_option_enum_CU_JIT_ERROR_LOG_BUFFER: CUjit_option_enum = 5;
pub const CUjit_option_enum_CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES: CUjit_option_enum = 6;
pub const CUjit_option_enum_CU_JIT_OPTIMIZATION_LEVEL: CUjit_option_enum = 7;
pub const CUjit_option_enum_CU_JIT_TARGET_FROM_CUCONTEXT: CUjit_option_enum = 8;
pub const CUjit_option_enum_CU_JIT_TARGET: CUjit_option_enum = 9;
pub const CUjit_option_enum_CU_JIT_FALLBACK_STRATEGY: CUjit_option_enum = 10;
pub const CUjit_option_enum_CU_JIT_GENERATE_DEBUG_INFO: CUjit_option_enum = 11;
pub const CUjit_option_enum_CU_JIT_LOG_VERBOSE: CUjit_option_enum = 12;
pub const CUjit_option_enum_CU_JIT_GENERATE_LINE_INFO: CUjit_option_enum = 13;
pub const CUjit_option_enum_CU_JIT_CACHE_MODE: CUjit_option_enum = 14;
pub const CUjit_option_enum_CU_JIT_NEW_SM3X_OPT: CUjit_option_enum = 15;
pub const CUjit_option_enum_CU_JIT_FAST_COMPILE: CUjit_option_enum = 16;
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_NAMES: CUjit_option_enum = 17;
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_ADDRESSES: CUjit_option_enum = 18;
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_COUNT: CUjit_option_enum = 19;
pub const CUjit_option_enum_CU_JIT_LTO: CUjit_option_enum = 20;
pub const CUjit_option_enum_CU_JIT_FTZ: CUjit_option_enum = 21;
pub const CUjit_option_enum_CU_JIT_PREC_DIV: CUjit_option_enum = 22;
pub const CUjit_option_enum_CU_JIT_PREC_SQRT: CUjit_option_enum = 23;
pub const CUjit_option_enum_CU_JIT_FMA: CUjit_option_enum = 24;
pub const CUjit_option_enum_CU_JIT_REFERENCED_KERNEL_NAMES: CUjit_option_enum = 25;
pub const CUjit_option_enum_CU_JIT_REFERENCED_KERNEL_COUNT: CUjit_option_enum = 26;
pub const CUjit_option_enum_CU_JIT_REFERENCED_VARIABLE_NAMES: CUjit_option_enum = 27;
pub const CUjit_option_enum_CU_JIT_REFERENCED_VARIABLE_COUNT: CUjit_option_enum = 28;
pub const CUjit_option_enum_CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES: CUjit_option_enum = 29;
pub const CUjit_option_enum_CU_JIT_NUM_OPTIONS: CUjit_option_enum = 30;
pub type CUjit_option_enum = ::std::os::raw::c_uint;
pub use self::CUjit_option_enum as CUjit_option;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_20: CUjit_target_enum = 20;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_21: CUjit_target_enum = 21;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_30: CUjit_target_enum = 30;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_32: CUjit_target_enum = 32;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_35: CUjit_target_enum = 35;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_37: CUjit_target_enum = 37;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_50: CUjit_target_enum = 50;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_52: CUjit_target_enum = 52;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_53: CUjit_target_enum = 53;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_60: CUjit_target_enum = 60;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_61: CUjit_target_enum = 61;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_62: CUjit_target_enum = 62;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_70: CUjit_target_enum = 70;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_72: CUjit_target_enum = 72;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_75: CUjit_target_enum = 75;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_80: CUjit_target_enum = 80;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_86: CUjit_target_enum = 86;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_87: CUjit_target_enum = 87;
pub type CUjit_target_enum = ::std::os::raw::c_uint;
pub use self::CUjit_target_enum as CUjit_target;
pub const CUjit_fallback_enum_CU_PREFER_PTX: CUjit_fallback_enum = 0;
pub const CUjit_fallback_enum_CU_PREFER_BINARY: CUjit_fallback_enum = 1;
pub type CUjit_fallback_enum = ::std::os::raw::c_uint;
pub use self::CUjit_fallback_enum as CUjit_fallback;
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_NONE: CUjit_cacheMode_enum = 0;
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_CG: CUjit_cacheMode_enum = 1;
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_CA: CUjit_cacheMode_enum = 2;
pub type CUjit_cacheMode_enum = ::std::os::raw::c_uint;
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
pub const CUjitInputType_enum_CU_JIT_INPUT_CUBIN: CUjitInputType_enum = 0;
pub const CUjitInputType_enum_CU_JIT_INPUT_PTX: CUjitInputType_enum = 1;
pub const CUjitInputType_enum_CU_JIT_INPUT_FATBINARY: CUjitInputType_enum = 2;
pub const CUjitInputType_enum_CU_JIT_INPUT_OBJECT: CUjitInputType_enum = 3;
pub const CUjitInputType_enum_CU_JIT_INPUT_LIBRARY: CUjitInputType_enum = 4;
pub const CUjitInputType_enum_CU_JIT_INPUT_NVVM: CUjitInputType_enum = 5;
pub const CUjitInputType_enum_CU_JIT_NUM_INPUT_TYPES: CUjitInputType_enum = 6;
pub type CUjitInputType_enum = ::std::os::raw::c_uint;
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_NONE:
    CUgraphicsRegisterFlags_enum = 0;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY:
    CUgraphicsRegisterFlags_enum = 1;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD:
    CUgraphicsRegisterFlags_enum = 2;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST:
    CUgraphicsRegisterFlags_enum = 4;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER:
    CUgraphicsRegisterFlags_enum = 8;
pub type CUgraphicsRegisterFlags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE:
    CUgraphicsMapResourceFlags_enum = 0;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY:
    CUgraphicsMapResourceFlags_enum = 1;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD:
    CUgraphicsMapResourceFlags_enum = 2;
pub type CUgraphicsMapResourceFlags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_X: CUarray_cubemap_face_enum = 0;
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_X: CUarray_cubemap_face_enum = 1;
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_Y: CUarray_cubemap_face_enum = 2;
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_Y: CUarray_cubemap_face_enum = 3;
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_Z: CUarray_cubemap_face_enum = 4;
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_Z: CUarray_cubemap_face_enum = 5;
pub type CUarray_cubemap_face_enum = ::std::os::raw::c_uint;
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
pub const CUlimit_enum_CU_LIMIT_STACK_SIZE: CUlimit_enum = 0;
pub const CUlimit_enum_CU_LIMIT_PRINTF_FIFO_SIZE: CUlimit_enum = 1;
pub const CUlimit_enum_CU_LIMIT_MALLOC_HEAP_SIZE: CUlimit_enum = 2;
pub const CUlimit_enum_CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH: CUlimit_enum = 3;
pub const CUlimit_enum_CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: CUlimit_enum = 4;
pub const CUlimit_enum_CU_LIMIT_MAX_L2_FETCH_GRANULARITY: CUlimit_enum = 5;
pub const CUlimit_enum_CU_LIMIT_PERSISTING_L2_CACHE_SIZE: CUlimit_enum = 6;
pub const CUlimit_enum_CU_LIMIT_MAX: CUlimit_enum = 7;
pub type CUlimit_enum = ::std::os::raw::c_uint;
pub use self::CUlimit_enum as CUlimit;
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_ARRAY: CUresourcetype_enum = 0;
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_MIPMAPPED_ARRAY: CUresourcetype_enum = 1;
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_LINEAR: CUresourcetype_enum = 2;
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_PITCH2D: CUresourcetype_enum = 3;
pub type CUresourcetype_enum = ::std::os::raw::c_uint;
pub use self::CUresourcetype_enum as CUresourcetype;
pub type CUhostFn =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_NORMAL: CUaccessProperty_enum = 0;
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_STREAMING: CUaccessProperty_enum = 1;
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_PERSISTING: CUaccessProperty_enum = 2;
pub type CUaccessProperty_enum = ::std::os::raw::c_uint;
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUaccessPolicyWindow_st {
    pub base_ptr: *mut ::std::os::raw::c_void,
    pub num_bytes: size_t,
    pub hitRatio: f32,
    pub hitProp: CUaccessProperty,
    pub missProp: CUaccessProperty,
}
#[test]
fn bindgen_test_layout_CUaccessPolicyWindow_st() {
    assert_eq!(
        ::std::mem::size_of::<CUaccessPolicyWindow_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUaccessPolicyWindow_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUaccessPolicyWindow_st))
    );
    fn test_field_base_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUaccessPolicyWindow_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUaccessPolicyWindow_st),
                "::",
                stringify!(base_ptr)
            )
        );
    }
    test_field_base_ptr();
    fn test_field_num_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUaccessPolicyWindow_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUaccessPolicyWindow_st),
                "::",
                stringify!(num_bytes)
            )
        );
    }
    test_field_num_bytes();
    fn test_field_hitRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUaccessPolicyWindow_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUaccessPolicyWindow_st),
                "::",
                stringify!(hitRatio)
            )
        );
    }
    test_field_hitRatio();
    fn test_field_hitProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUaccessPolicyWindow_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUaccessPolicyWindow_st),
                "::",
                stringify!(hitProp)
            )
        );
    }
    test_field_hitProp();
    fn test_field_missProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUaccessPolicyWindow_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUaccessPolicyWindow_st),
                "::",
                stringify!(missProp)
            )
        );
    }
    test_field_missProp();
}
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    pub func: CUfunction,
    pub gridDimX: ::std::os::raw::c_uint,
    pub gridDimY: ::std::os::raw::c_uint,
    pub gridDimZ: ::std::os::raw::c_uint,
    pub blockDimX: ::std::os::raw::c_uint,
    pub blockDimY: ::std::os::raw::c_uint,
    pub blockDimZ: ::std::os::raw::c_uint,
    pub sharedMemBytes: ::std::os::raw::c_uint,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDimX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(gridDimX)
            )
        );
    }
    test_field_gridDimX();
    fn test_field_gridDimY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(gridDimY)
            )
        );
    }
    test_field_gridDimY();
    fn test_field_gridDimZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(gridDimZ)
            )
        );
    }
    test_field_gridDimZ();
    fn test_field_blockDimX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(blockDimX)
            )
        );
    }
    test_field_blockDimX();
    fn test_field_blockDimY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(blockDimY)
            )
        );
    }
    test_field_blockDimY();
    fn test_field_blockDimZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(blockDimZ)
            )
        );
    }
    test_field_blockDimZ();
    fn test_field_sharedMemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(sharedMemBytes)
            )
        );
    }
    test_field_sharedMemBytes();
    fn test_field_kernelParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(kernelParams)
            )
        );
    }
    test_field_kernelParams();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_KERNEL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_KERNEL_NODE_PARAMS_st),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
pub type CUDA_KERNEL_NODE_PARAMS_v1 = CUDA_KERNEL_NODE_PARAMS_st;
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    pub dst: CUdeviceptr,
    pub pitch: size_t,
    pub value: ::std::os::raw::c_uint,
    pub elementSize: ::std::os::raw::c_uint,
    pub width: size_t,
    pub height: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMSET_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMSET_NODE_PARAMS_st),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMSET_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMSET_NODE_PARAMS_st),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMSET_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMSET_NODE_PARAMS_st),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_elementSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMSET_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMSET_NODE_PARAMS_st),
                "::",
                stringify!(elementSize)
            )
        );
    }
    test_field_elementSize();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMSET_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMSET_NODE_PARAMS_st),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMSET_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMSET_NODE_PARAMS_st),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
pub type CUDA_MEMSET_NODE_PARAMS_v1 = CUDA_MEMSET_NODE_PARAMS_st;
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    pub fn_: CUhostFn,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_HOST_NODE_PARAMS_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_HOST_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    fn test_field_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_HOST_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_HOST_NODE_PARAMS_st),
                "::",
                stringify!(fn_)
            )
        );
    }
    test_field_fn();
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_HOST_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_HOST_NODE_PARAMS_st),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
}
pub type CUDA_HOST_NODE_PARAMS_v1 = CUDA_HOST_NODE_PARAMS_st;
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_v1;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_KERNEL: CUgraphNodeType_enum = 0;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEMCPY: CUgraphNodeType_enum = 1;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEMSET: CUgraphNodeType_enum = 2;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_HOST: CUgraphNodeType_enum = 3;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_GRAPH: CUgraphNodeType_enum = 4;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EMPTY: CUgraphNodeType_enum = 5;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_WAIT_EVENT: CUgraphNodeType_enum = 6;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EVENT_RECORD: CUgraphNodeType_enum = 7;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL: CUgraphNodeType_enum = 8;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT: CUgraphNodeType_enum = 9;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEM_ALLOC: CUgraphNodeType_enum = 10;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEM_FREE: CUgraphNodeType_enum = 11;
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_BATCH_MEM_OP: CUgraphNodeType_enum = 12;
pub type CUgraphNodeType_enum = ::std::os::raw::c_uint;
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_AUTO: CUsynchronizationPolicy_enum = 1;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_SPIN: CUsynchronizationPolicy_enum = 2;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_YIELD: CUsynchronizationPolicy_enum = 3;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_BLOCKING_SYNC: CUsynchronizationPolicy_enum =
    4;
pub type CUsynchronizationPolicy_enum = ::std::os::raw::c_uint;
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
pub const CUkernelNodeAttrID_enum_CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW:
    CUkernelNodeAttrID_enum = 1;
pub const CUkernelNodeAttrID_enum_CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE: CUkernelNodeAttrID_enum = 2;
pub const CUkernelNodeAttrID_enum_CU_KERNEL_NODE_ATTRIBUTE_PRIORITY: CUkernelNodeAttrID_enum = 8;
pub type CUkernelNodeAttrID_enum = ::std::os::raw::c_uint;
pub use self::CUkernelNodeAttrID_enum as CUkernelNodeAttrID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUkernelNodeAttrValue_union {
    pub accessPolicyWindow: CUaccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUkernelNodeAttrValue_union() {
    assert_eq!(
        ::std::mem::size_of::<CUkernelNodeAttrValue_union>(),
        32usize,
        concat!("Size of: ", stringify!(CUkernelNodeAttrValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUkernelNodeAttrValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUkernelNodeAttrValue_union))
    );
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUkernelNodeAttrValue_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUkernelNodeAttrValue_union),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_cooperative() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUkernelNodeAttrValue_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUkernelNodeAttrValue_union),
                "::",
                stringify!(cooperative)
            )
        );
    }
    test_field_cooperative();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUkernelNodeAttrValue_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUkernelNodeAttrValue_union),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
}
pub type CUkernelNodeAttrValue_v1 = CUkernelNodeAttrValue_union;
pub type CUkernelNodeAttrValue = CUkernelNodeAttrValue_v1;
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_NONE: CUstreamCaptureStatus_enum = 0;
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_ACTIVE: CUstreamCaptureStatus_enum =
    1;
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_INVALIDATED:
    CUstreamCaptureStatus_enum = 2;
pub type CUstreamCaptureStatus_enum = ::std::os::raw::c_uint;
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_GLOBAL: CUstreamCaptureMode_enum = 0;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_THREAD_LOCAL: CUstreamCaptureMode_enum =
    1;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_RELAXED: CUstreamCaptureMode_enum = 2;
pub type CUstreamCaptureMode_enum = ::std::os::raw::c_uint;
pub use self::CUstreamCaptureMode_enum as CUstreamCaptureMode;
pub const CUstreamAttrID_enum_CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW: CUstreamAttrID_enum = 1;
pub const CUstreamAttrID_enum_CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY: CUstreamAttrID_enum = 3;
pub type CUstreamAttrID_enum = ::std::os::raw::c_uint;
pub use self::CUstreamAttrID_enum as CUstreamAttrID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamAttrValue_union {
    pub accessPolicyWindow: CUaccessPolicyWindow,
    pub syncPolicy: CUsynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_CUstreamAttrValue_union() {
    assert_eq!(
        ::std::mem::size_of::<CUstreamAttrValue_union>(),
        32usize,
        concat!("Size of: ", stringify!(CUstreamAttrValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamAttrValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamAttrValue_union))
    );
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamAttrValue_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamAttrValue_union),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_syncPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUstreamAttrValue_union>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUstreamAttrValue_union),
                "::",
                stringify!(syncPolicy)
            )
        );
    }
    test_field_syncPolicy();
}
pub type CUstreamAttrValue_v1 = CUstreamAttrValue_union;
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_DEFAULT:
    CUdriverProcAddress_flags_enum = 0;
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_LEGACY_STREAM:
    CUdriverProcAddress_flags_enum = 1;
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM:
    CUdriverProcAddress_flags_enum = 2;
pub type CUdriverProcAddress_flags_enum = ::std::os::raw::c_uint;
pub use self::CUdriverProcAddress_flags_enum as CUdriverProcAddress_flags;
pub const CUexecAffinityType_enum_CU_EXEC_AFFINITY_TYPE_SM_COUNT: CUexecAffinityType_enum = 0;
pub const CUexecAffinityType_enum_CU_EXEC_AFFINITY_TYPE_MAX: CUexecAffinityType_enum = 1;
pub type CUexecAffinityType_enum = ::std::os::raw::c_uint;
pub use self::CUexecAffinityType_enum as CUexecAffinityType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexecAffinitySmCount_st {
    pub val: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUexecAffinitySmCount_st() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Size of: ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinitySmCount_st))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUexecAffinitySmCount_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUexecAffinitySmCount_st),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
pub type CUexecAffinitySmCount_v1 = CUexecAffinitySmCount_st;
pub type CUexecAffinitySmCount = CUexecAffinitySmCount_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUexecAffinityParam_st {
    pub type_: CUexecAffinityType,
    pub param: CUexecAffinityParam_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUexecAffinityParam_st__bindgen_ty_1 {
    pub smCount: CUexecAffinitySmCount,
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    fn test_field_smCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUexecAffinityParam_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).smCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUexecAffinityParam_st__bindgen_ty_1),
                "::",
                stringify!(smCount)
            )
        );
    }
    test_field_smCount();
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st() {
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinityParam_st))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUexecAffinityParam_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUexecAffinityParam_st),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_param() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUexecAffinityParam_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUexecAffinityParam_st),
                "::",
                stringify!(param)
            )
        );
    }
    test_field_param();
}
pub type CUexecAffinityParam_v1 = CUexecAffinityParam_st;
pub type CUexecAffinityParam = CUexecAffinityParam_v1;
pub const cudaError_enum_CUDA_SUCCESS: cudaError_enum = 0;
pub const cudaError_enum_CUDA_ERROR_INVALID_VALUE: cudaError_enum = 1;
pub const cudaError_enum_CUDA_ERROR_OUT_OF_MEMORY: cudaError_enum = 2;
pub const cudaError_enum_CUDA_ERROR_NOT_INITIALIZED: cudaError_enum = 3;
pub const cudaError_enum_CUDA_ERROR_DEINITIALIZED: cudaError_enum = 4;
pub const cudaError_enum_CUDA_ERROR_PROFILER_DISABLED: cudaError_enum = 5;
pub const cudaError_enum_CUDA_ERROR_PROFILER_NOT_INITIALIZED: cudaError_enum = 6;
pub const cudaError_enum_CUDA_ERROR_PROFILER_ALREADY_STARTED: cudaError_enum = 7;
pub const cudaError_enum_CUDA_ERROR_PROFILER_ALREADY_STOPPED: cudaError_enum = 8;
pub const cudaError_enum_CUDA_ERROR_STUB_LIBRARY: cudaError_enum = 34;
pub const cudaError_enum_CUDA_ERROR_DEVICE_UNAVAILABLE: cudaError_enum = 46;
pub const cudaError_enum_CUDA_ERROR_NO_DEVICE: cudaError_enum = 100;
pub const cudaError_enum_CUDA_ERROR_INVALID_DEVICE: cudaError_enum = 101;
pub const cudaError_enum_CUDA_ERROR_DEVICE_NOT_LICENSED: cudaError_enum = 102;
pub const cudaError_enum_CUDA_ERROR_INVALID_IMAGE: cudaError_enum = 200;
pub const cudaError_enum_CUDA_ERROR_INVALID_CONTEXT: cudaError_enum = 201;
pub const cudaError_enum_CUDA_ERROR_CONTEXT_ALREADY_CURRENT: cudaError_enum = 202;
pub const cudaError_enum_CUDA_ERROR_MAP_FAILED: cudaError_enum = 205;
pub const cudaError_enum_CUDA_ERROR_UNMAP_FAILED: cudaError_enum = 206;
pub const cudaError_enum_CUDA_ERROR_ARRAY_IS_MAPPED: cudaError_enum = 207;
pub const cudaError_enum_CUDA_ERROR_ALREADY_MAPPED: cudaError_enum = 208;
pub const cudaError_enum_CUDA_ERROR_NO_BINARY_FOR_GPU: cudaError_enum = 209;
pub const cudaError_enum_CUDA_ERROR_ALREADY_ACQUIRED: cudaError_enum = 210;
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED: cudaError_enum = 211;
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED_AS_ARRAY: cudaError_enum = 212;
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED_AS_POINTER: cudaError_enum = 213;
pub const cudaError_enum_CUDA_ERROR_ECC_UNCORRECTABLE: cudaError_enum = 214;
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_LIMIT: cudaError_enum = 215;
pub const cudaError_enum_CUDA_ERROR_CONTEXT_ALREADY_IN_USE: cudaError_enum = 216;
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_UNSUPPORTED: cudaError_enum = 217;
pub const cudaError_enum_CUDA_ERROR_INVALID_PTX: cudaError_enum = 218;
pub const cudaError_enum_CUDA_ERROR_INVALID_GRAPHICS_CONTEXT: cudaError_enum = 219;
pub const cudaError_enum_CUDA_ERROR_NVLINK_UNCORRECTABLE: cudaError_enum = 220;
pub const cudaError_enum_CUDA_ERROR_JIT_COMPILER_NOT_FOUND: cudaError_enum = 221;
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_PTX_VERSION: cudaError_enum = 222;
pub const cudaError_enum_CUDA_ERROR_JIT_COMPILATION_DISABLED: cudaError_enum = 223;
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY: cudaError_enum = 224;
pub const cudaError_enum_CUDA_ERROR_INVALID_SOURCE: cudaError_enum = 300;
pub const cudaError_enum_CUDA_ERROR_FILE_NOT_FOUND: cudaError_enum = 301;
pub const cudaError_enum_CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND: cudaError_enum = 302;
pub const cudaError_enum_CUDA_ERROR_SHARED_OBJECT_INIT_FAILED: cudaError_enum = 303;
pub const cudaError_enum_CUDA_ERROR_OPERATING_SYSTEM: cudaError_enum = 304;
pub const cudaError_enum_CUDA_ERROR_INVALID_HANDLE: cudaError_enum = 400;
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_STATE: cudaError_enum = 401;
pub const cudaError_enum_CUDA_ERROR_NOT_FOUND: cudaError_enum = 500;
pub const cudaError_enum_CUDA_ERROR_NOT_READY: cudaError_enum = 600;
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_ADDRESS: cudaError_enum = 700;
pub const cudaError_enum_CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES: cudaError_enum = 701;
pub const cudaError_enum_CUDA_ERROR_LAUNCH_TIMEOUT: cudaError_enum = 702;
pub const cudaError_enum_CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING: cudaError_enum = 703;
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED: cudaError_enum = 704;
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_NOT_ENABLED: cudaError_enum = 705;
pub const cudaError_enum_CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE: cudaError_enum = 708;
pub const cudaError_enum_CUDA_ERROR_CONTEXT_IS_DESTROYED: cudaError_enum = 709;
pub const cudaError_enum_CUDA_ERROR_ASSERT: cudaError_enum = 710;
pub const cudaError_enum_CUDA_ERROR_TOO_MANY_PEERS: cudaError_enum = 711;
pub const cudaError_enum_CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED: cudaError_enum = 712;
pub const cudaError_enum_CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED: cudaError_enum = 713;
pub const cudaError_enum_CUDA_ERROR_HARDWARE_STACK_ERROR: cudaError_enum = 714;
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_INSTRUCTION: cudaError_enum = 715;
pub const cudaError_enum_CUDA_ERROR_MISALIGNED_ADDRESS: cudaError_enum = 716;
pub const cudaError_enum_CUDA_ERROR_INVALID_ADDRESS_SPACE: cudaError_enum = 717;
pub const cudaError_enum_CUDA_ERROR_INVALID_PC: cudaError_enum = 718;
pub const cudaError_enum_CUDA_ERROR_LAUNCH_FAILED: cudaError_enum = 719;
pub const cudaError_enum_CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE: cudaError_enum = 720;
pub const cudaError_enum_CUDA_ERROR_NOT_PERMITTED: cudaError_enum = 800;
pub const cudaError_enum_CUDA_ERROR_NOT_SUPPORTED: cudaError_enum = 801;
pub const cudaError_enum_CUDA_ERROR_SYSTEM_NOT_READY: cudaError_enum = 802;
pub const cudaError_enum_CUDA_ERROR_SYSTEM_DRIVER_MISMATCH: cudaError_enum = 803;
pub const cudaError_enum_CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE: cudaError_enum = 804;
pub const cudaError_enum_CUDA_ERROR_MPS_CONNECTION_FAILED: cudaError_enum = 805;
pub const cudaError_enum_CUDA_ERROR_MPS_RPC_FAILURE: cudaError_enum = 806;
pub const cudaError_enum_CUDA_ERROR_MPS_SERVER_NOT_READY: cudaError_enum = 807;
pub const cudaError_enum_CUDA_ERROR_MPS_MAX_CLIENTS_REACHED: cudaError_enum = 808;
pub const cudaError_enum_CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED: cudaError_enum = 809;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED: cudaError_enum = 900;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_INVALIDATED: cudaError_enum = 901;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_MERGE: cudaError_enum = 902;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNMATCHED: cudaError_enum = 903;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNJOINED: cudaError_enum = 904;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_ISOLATION: cudaError_enum = 905;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_IMPLICIT: cudaError_enum = 906;
pub const cudaError_enum_CUDA_ERROR_CAPTURED_EVENT: cudaError_enum = 907;
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD: cudaError_enum = 908;
pub const cudaError_enum_CUDA_ERROR_TIMEOUT: cudaError_enum = 909;
pub const cudaError_enum_CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE: cudaError_enum = 910;
pub const cudaError_enum_CUDA_ERROR_EXTERNAL_DEVICE: cudaError_enum = 911;
pub const cudaError_enum_CUDA_ERROR_UNKNOWN: cudaError_enum = 999;
pub type cudaError_enum = ::std::os::raw::c_uint;
pub use self::cudaError_enum as CUresult;
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK:
    CUdevice_P2PAttribute_enum = 1;
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 2;
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED:
    CUdevice_P2PAttribute_enum = 3;
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 4;
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 4;
pub type CUdevice_P2PAttribute_enum = ::std::os::raw::c_uint;
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
pub type CUoccupancyB2DSize =
    ::std::option::Option<unsafe extern "C" fn(blockSize: ::std::os::raw::c_int) -> size_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY2D_st {
    pub srcXInBytes: size_t,
    pub srcY: size_t,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcPitch: size_t,
    pub dstXInBytes: size_t,
    pub dstY: size_t,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstPitch: size_t,
    pub WidthInBytes: size_t,
    pub Height: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY2D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY2D_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY2D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY2D_st))
    );
    fn test_field_srcXInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcXInBytes)
            )
        );
    }
    test_field_srcXInBytes();
    fn test_field_srcY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcY)
            )
        );
    }
    test_field_srcY();
    fn test_field_srcMemoryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcMemoryType)
            )
        );
    }
    test_field_srcMemoryType();
    fn test_field_srcHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcHost)
            )
        );
    }
    test_field_srcHost();
    fn test_field_srcDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcDevice)
            )
        );
    }
    test_field_srcDevice();
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(srcPitch)
            )
        );
    }
    test_field_srcPitch();
    fn test_field_dstXInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstXInBytes)
            )
        );
    }
    test_field_dstXInBytes();
    fn test_field_dstY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstY)
            )
        );
    }
    test_field_dstY();
    fn test_field_dstMemoryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstMemoryType)
            )
        );
    }
    test_field_dstMemoryType();
    fn test_field_dstHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstHost)
            )
        );
    }
    test_field_dstHost();
    fn test_field_dstDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstDevice)
            )
        );
    }
    test_field_dstDevice();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(dstPitch)
            )
        );
    }
    test_field_dstPitch();
    fn test_field_WidthInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(WidthInBytes)
            )
        );
    }
    test_field_WidthInBytes();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY2D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY2D_st),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
pub type CUDA_MEMCPY2D_v2 = CUDA_MEMCPY2D_st;
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_st {
    pub srcXInBytes: size_t,
    pub srcY: size_t,
    pub srcZ: size_t,
    pub srcLOD: size_t,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub srcPitch: size_t,
    pub srcHeight: size_t,
    pub dstXInBytes: size_t,
    pub dstY: size_t,
    pub dstZ: size_t,
    pub dstLOD: size_t,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub dstPitch: size_t,
    pub dstHeight: size_t,
    pub WidthInBytes: size_t,
    pub Height: size_t,
    pub Depth: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_st))
    );
    fn test_field_srcXInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcXInBytes)
            )
        );
    }
    test_field_srcXInBytes();
    fn test_field_srcY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcY)
            )
        );
    }
    test_field_srcY();
    fn test_field_srcZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcZ)
            )
        );
    }
    test_field_srcZ();
    fn test_field_srcLOD() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcLOD)
            )
        );
    }
    test_field_srcLOD();
    fn test_field_srcMemoryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcMemoryType)
            )
        );
    }
    test_field_srcMemoryType();
    fn test_field_srcHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcHost)
            )
        );
    }
    test_field_srcHost();
    fn test_field_srcDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcDevice)
            )
        );
    }
    test_field_srcDevice();
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_srcPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcPitch)
            )
        );
    }
    test_field_srcPitch();
    fn test_field_srcHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(srcHeight)
            )
        );
    }
    test_field_srcHeight();
    fn test_field_dstXInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstXInBytes)
            )
        );
    }
    test_field_dstXInBytes();
    fn test_field_dstY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstY)
            )
        );
    }
    test_field_dstY();
    fn test_field_dstZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstZ)
            )
        );
    }
    test_field_dstZ();
    fn test_field_dstLOD() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstLOD)
            )
        );
    }
    test_field_dstLOD();
    fn test_field_dstMemoryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstMemoryType)
            )
        );
    }
    test_field_dstMemoryType();
    fn test_field_dstHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstHost)
            )
        );
    }
    test_field_dstHost();
    fn test_field_dstDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstDevice)
            )
        );
    }
    test_field_dstDevice();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_dstPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstPitch)
            )
        );
    }
    test_field_dstPitch();
    fn test_field_dstHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(dstHeight)
            )
        );
    }
    test_field_dstHeight();
    fn test_field_WidthInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(WidthInBytes)
            )
        );
    }
    test_field_WidthInBytes();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_Depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_st),
                "::",
                stringify!(Depth)
            )
        );
    }
    test_field_Depth();
}
pub type CUDA_MEMCPY3D_v2 = CUDA_MEMCPY3D_st;
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_PEER_st {
    pub srcXInBytes: size_t,
    pub srcY: size_t,
    pub srcZ: size_t,
    pub srcLOD: size_t,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::std::os::raw::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcContext: CUcontext,
    pub srcPitch: size_t,
    pub srcHeight: size_t,
    pub dstXInBytes: size_t,
    pub dstY: size_t,
    pub dstZ: size_t,
    pub dstLOD: size_t,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::std::os::raw::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstContext: CUcontext,
    pub dstPitch: size_t,
    pub dstHeight: size_t,
    pub WidthInBytes: size_t,
    pub Height: size_t,
    pub Depth: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_PEER_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_PEER_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_PEER_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    fn test_field_srcXInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcXInBytes)
            )
        );
    }
    test_field_srcXInBytes();
    fn test_field_srcY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcY)
            )
        );
    }
    test_field_srcY();
    fn test_field_srcZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcZ)
            )
        );
    }
    test_field_srcZ();
    fn test_field_srcLOD() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcLOD)
            )
        );
    }
    test_field_srcLOD();
    fn test_field_srcMemoryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcMemoryType)
            )
        );
    }
    test_field_srcMemoryType();
    fn test_field_srcHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcHost)
            )
        );
    }
    test_field_srcHost();
    fn test_field_srcDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcDevice)
            )
        );
    }
    test_field_srcDevice();
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcContext) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcContext)
            )
        );
    }
    test_field_srcContext();
    fn test_field_srcPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcPitch)
            )
        );
    }
    test_field_srcPitch();
    fn test_field_srcHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(srcHeight)
            )
        );
    }
    test_field_srcHeight();
    fn test_field_dstXInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstXInBytes)
            )
        );
    }
    test_field_dstXInBytes();
    fn test_field_dstY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstY)
            )
        );
    }
    test_field_dstY();
    fn test_field_dstZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstZ)
            )
        );
    }
    test_field_dstZ();
    fn test_field_dstLOD() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstLOD)
            )
        );
    }
    test_field_dstLOD();
    fn test_field_dstMemoryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstMemoryType)
            )
        );
    }
    test_field_dstMemoryType();
    fn test_field_dstHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstHost)
            )
        );
    }
    test_field_dstHost();
    fn test_field_dstDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstDevice)
            )
        );
    }
    test_field_dstDevice();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstContext) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstContext)
            )
        );
    }
    test_field_dstContext();
    fn test_field_dstPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstPitch)
            )
        );
    }
    test_field_dstPitch();
    fn test_field_dstHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(dstHeight)
            )
        );
    }
    test_field_dstHeight();
    fn test_field_WidthInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(WidthInBytes)
            )
        );
    }
    test_field_WidthInBytes();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_Depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEMCPY3D_PEER_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEMCPY3D_PEER_st),
                "::",
                stringify!(Depth)
            )
        );
    }
    test_field_Depth();
}
pub type CUDA_MEMCPY3D_PEER_v1 = CUDA_MEMCPY3D_PEER_st;
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    pub Width: size_t,
    pub Height: size_t,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_DESCRIPTOR_st),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_DESCRIPTOR_st),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_Format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Format) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_DESCRIPTOR_st),
                "::",
                stringify!(Format)
            )
        );
    }
    test_field_Format();
    fn test_field_NumChannels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_DESCRIPTOR_st),
                "::",
                stringify!(NumChannels)
            )
        );
    }
    test_field_NumChannels();
}
pub type CUDA_ARRAY_DESCRIPTOR_v2 = CUDA_ARRAY_DESCRIPTOR_st;
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    pub Width: size_t,
    pub Height: size_t,
    pub Depth: size_t,
    pub Format: CUarray_format,
    pub NumChannels: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY3D_DESCRIPTOR_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY3D_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY3D_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_Depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY3D_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
                "::",
                stringify!(Depth)
            )
        );
    }
    test_field_Depth();
    fn test_field_Format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY3D_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Format) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
                "::",
                stringify!(Format)
            )
        );
    }
    test_field_Format();
    fn test_field_NumChannels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY3D_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
                "::",
                stringify!(NumChannels)
            )
        );
    }
    test_field_NumChannels();
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY3D_DESCRIPTOR_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
                "::",
                stringify!(Flags)
            )
        );
    }
    test_field_Flags();
}
pub type CUDA_ARRAY3D_DESCRIPTOR_v2 = CUDA_ARRAY3D_DESCRIPTOR_st;
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    pub tileExtent: CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1,
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    pub miptailSize: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        48usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    fn test_field_tileExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_SPARSE_PROPERTIES_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
                "::",
                stringify!(tileExtent)
            )
        );
    }
    test_field_tileExtent();
    fn test_field_miptailFirstLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_SPARSE_PROPERTIES_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
                "::",
                stringify!(miptailFirstLevel)
            )
        );
    }
    test_field_miptailFirstLevel();
    fn test_field_miptailSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_SPARSE_PROPERTIES_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
                "::",
                stringify!(miptailSize)
            )
        );
    }
    test_field_miptailSize();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_SPARSE_PROPERTIES_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_SPARSE_PROPERTIES_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_ARRAY_SPARSE_PROPERTIES_v1 = CUDA_ARRAY_SPARSE_PROPERTIES_st;
pub type CUDA_ARRAY_SPARSE_PROPERTIES = CUDA_ARRAY_SPARSE_PROPERTIES_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st {
    pub size: size_t,
    pub alignment: size_t,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_MEMORY_REQUIREMENTS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st)
        )
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 = CUDA_ARRAY_MEMORY_REQUIREMENTS_st;
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS = CUDA_ARRAY_MEMORY_REQUIREMENTS_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub hArray: CUarray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_hArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(hArray)
            )
        );
    }
    test_field_hArray();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    pub hMipmappedArray: CUmipmappedArray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_hMipmappedArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hMipmappedArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(hMipmappedArray)
            )
        );
    }
    test_field_hMipmappedArray();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub sizeInBytes: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_numChannels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(numChannels)
            )
        );
    }
    test_field_numChannels();
    fn test_field_sizeInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(sizeInBytes)
            )
        );
    }
    test_field_sizeInBytes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::std::os::raw::c_uint,
    pub width: size_t,
    pub height: size_t,
    pub pitchInBytes: size_t,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_numChannels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(numChannels)
            )
        );
    }
    test_field_numChannels();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_pitchInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(pitchInBytes)
            )
        );
    }
    test_field_pitchInBytes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
    fn test_field_linear() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(linear)
            )
        );
    }
    test_field_linear();
    fn test_field_pitch2D() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(pitch2D)
            )
        );
    }
    test_field_pitch2D();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    fn test_field_resType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st),
                "::",
                stringify!(resType)
            )
        );
    }
    test_field_resType();
    fn test_field_res() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st),
                "::",
                stringify!(res)
            )
        );
    }
    test_field_res();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_DESC_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
pub type CUDA_RESOURCE_DESC_v1 = CUDA_RESOURCE_DESC_st;
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_TEXTURE_DESC_st {
    pub addressMode: [CUaddress_mode; 3usize],
    pub filterMode: CUfilter_mode,
    pub flags: ::std::os::raw::c_uint,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: CUfilter_mode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_CUDA_TEXTURE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    fn test_field_addressMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(addressMode)
            )
        );
    }
    test_field_addressMode();
    fn test_field_filterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(filterMode)
            )
        );
    }
    test_field_filterMode();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_maxAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(maxAnisotropy)
            )
        );
    }
    test_field_maxAnisotropy();
    fn test_field_mipmapFilterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(mipmapFilterMode)
            )
        );
    }
    test_field_mipmapFilterMode();
    fn test_field_mipmapLevelBias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(mipmapLevelBias)
            )
        );
    }
    test_field_mipmapLevelBias();
    fn test_field_minMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(minMipmapLevelClamp)
            )
        );
    }
    test_field_minMipmapLevelClamp();
    fn test_field_maxMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(maxMipmapLevelClamp)
            )
        );
    }
    test_field_maxMipmapLevelClamp();
    fn test_field_borderColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(borderColor)
            )
        );
    }
    test_field_borderColor();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_TEXTURE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_TEXTURE_DESC_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_TEXTURE_DESC_v1 = CUDA_TEXTURE_DESC_st;
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_v1;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_NONE: CUresourceViewFormat_enum = 0;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X8: CUresourceViewFormat_enum = 1;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X8: CUresourceViewFormat_enum = 2;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X8: CUresourceViewFormat_enum = 3;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X8: CUresourceViewFormat_enum = 4;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X8: CUresourceViewFormat_enum = 5;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X8: CUresourceViewFormat_enum = 6;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X16: CUresourceViewFormat_enum = 7;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X16: CUresourceViewFormat_enum = 8;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X16: CUresourceViewFormat_enum = 9;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X16: CUresourceViewFormat_enum = 10;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X16: CUresourceViewFormat_enum = 11;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X16: CUresourceViewFormat_enum = 12;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X32: CUresourceViewFormat_enum = 13;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X32: CUresourceViewFormat_enum = 14;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X32: CUresourceViewFormat_enum = 15;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X32: CUresourceViewFormat_enum = 16;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X32: CUresourceViewFormat_enum = 17;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X32: CUresourceViewFormat_enum = 18;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_1X16: CUresourceViewFormat_enum = 19;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_2X16: CUresourceViewFormat_enum = 20;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_4X16: CUresourceViewFormat_enum = 21;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_1X32: CUresourceViewFormat_enum = 22;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_2X32: CUresourceViewFormat_enum = 23;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_4X32: CUresourceViewFormat_enum = 24;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC1: CUresourceViewFormat_enum = 25;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC2: CUresourceViewFormat_enum = 26;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC3: CUresourceViewFormat_enum = 27;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC4: CUresourceViewFormat_enum = 28;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC4: CUresourceViewFormat_enum = 29;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC5: CUresourceViewFormat_enum = 30;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC5: CUresourceViewFormat_enum = 31;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC6H: CUresourceViewFormat_enum =
    32;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC6H: CUresourceViewFormat_enum = 33;
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC7: CUresourceViewFormat_enum = 34;
pub type CUresourceViewFormat_enum = ::std::os::raw::c_uint;
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    pub format: CUresourceViewFormat,
    pub width: size_t,
    pub height: size_t,
    pub depth: size_t,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_VIEW_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_firstMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(firstMipmapLevel)
            )
        );
    }
    test_field_firstMipmapLevel();
    fn test_field_lastMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(lastMipmapLevel)
            )
        );
    }
    test_field_lastMipmapLevel();
    fn test_field_firstLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(firstLayer)
            )
        );
    }
    test_field_firstLayer();
    fn test_field_lastLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(lastLayer)
            )
        );
    }
    test_field_lastLayer();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_RESOURCE_VIEW_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_RESOURCE_VIEW_DESC_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_RESOURCE_VIEW_DESC_v1 = CUDA_RESOURCE_VIEW_DESC_st;
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::std::os::raw::c_ulonglong,
    pub vaSpaceToken: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    fn test_field_p2pToken() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p2pToken) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
                "::",
                stringify!(p2pToken)
            )
        );
    }
    test_field_p2pToken();
    fn test_field_vaSpaceToken() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vaSpaceToken) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
                "::",
                stringify!(vaSpaceToken)
            )
        );
    }
    test_field_vaSpaceToken();
}
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 0;
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 1;
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 3;
pub type CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = ::std::os::raw::c_uint;
pub use self::CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum as CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_LAUNCH_PARAMS_st {
    pub function: CUfunction,
    pub gridDimX: ::std::os::raw::c_uint,
    pub gridDimY: ::std::os::raw::c_uint,
    pub gridDimZ: ::std::os::raw::c_uint,
    pub blockDimX: ::std::os::raw::c_uint,
    pub blockDimY: ::std::os::raw::c_uint,
    pub blockDimZ: ::std::os::raw::c_uint,
    pub sharedMemBytes: ::std::os::raw::c_uint,
    pub hStream: CUstream,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_LAUNCH_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_LAUNCH_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_LAUNCH_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    fn test_field_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(function)
            )
        );
    }
    test_field_function();
    fn test_field_gridDimX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(gridDimX)
            )
        );
    }
    test_field_gridDimX();
    fn test_field_gridDimY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(gridDimY)
            )
        );
    }
    test_field_gridDimY();
    fn test_field_gridDimZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(gridDimZ)
            )
        );
    }
    test_field_gridDimZ();
    fn test_field_blockDimX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(blockDimX)
            )
        );
    }
    test_field_blockDimX();
    fn test_field_blockDimY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(blockDimY)
            )
        );
    }
    test_field_blockDimY();
    fn test_field_blockDimZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(blockDimZ)
            )
        );
    }
    test_field_blockDimZ();
    fn test_field_sharedMemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(sharedMemBytes)
            )
        );
    }
    test_field_sharedMemBytes();
    fn test_field_hStream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hStream) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(hStream)
            )
        );
    }
    test_field_hStream();
    fn test_field_kernelParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_LAUNCH_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_LAUNCH_PARAMS_st),
                "::",
                stringify!(kernelParams)
            )
        );
    }
    test_field_kernelParams();
}
pub type CUDA_LAUNCH_PARAMS_v1 = CUDA_LAUNCH_PARAMS_st;
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_v1;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD:
    CUexternalMemoryHandleType_enum = 1;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32:
    CUexternalMemoryHandleType_enum = 2;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT:
    CUexternalMemoryHandleType_enum = 3;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP:
    CUexternalMemoryHandleType_enum = 4;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE:
    CUexternalMemoryHandleType_enum = 5;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE:
    CUexternalMemoryHandleType_enum = 6;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT:
    CUexternalMemoryHandleType_enum = 7;
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF:
    CUexternalMemoryHandleType_enum = 8;
pub type CUexternalMemoryHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciBufObject() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(nvSciBufObject)
            )
        );
    }
    test_field_nvSciBufObject();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
        )
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    pub offset: ::std::os::raw::c_ulonglong,
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_arrayDesc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrayDesc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
                "::",
                stringify!(arrayDesc)
            )
        );
    }
    test_field_arrayDesc();
    fn test_field_numLevels() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
                "::",
                stringify!(numLevels)
            )
        );
    }
    test_field_numLevels();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 =
    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD:
    CUexternalSemaphoreHandleType_enum = 1;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32:
    CUexternalSemaphoreHandleType_enum = 2;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT:
    CUexternalSemaphoreHandleType_enum = 3;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE:
    CUexternalSemaphoreHandleType_enum = 4;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE:
    CUexternalSemaphoreHandleType_enum = 5;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC:
    CUexternalSemaphoreHandleType_enum = 6;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX:
    CUexternalSemaphoreHandleType_enum = 7;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT : CUexternalSemaphoreHandleType_enum = 8 ;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD : CUexternalSemaphoreHandleType_enum = 9 ;
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 : CUexternalSemaphoreHandleType_enum = 10 ;
pub type CUexternalSemaphoreHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciSyncObj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
                "::",
                stringify!(nvSciSyncObj)
            )
        );
    }
    test_field_nvSciSyncObj();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_WAIT_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
pub type CUmemGenericAllocationHandle_v1 = ::std::os::raw::c_ulonglong;
pub type CUmemGenericAllocationHandle = CUmemGenericAllocationHandle_v1;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_NONE: CUmemAllocationHandleType_enum =
    0;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR:
    CUmemAllocationHandleType_enum = 1;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_WIN32: CUmemAllocationHandleType_enum =
    2;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_WIN32_KMT:
    CUmemAllocationHandleType_enum = 4;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_MAX: CUmemAllocationHandleType_enum =
    2147483647;
pub type CUmemAllocationHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationHandleType_enum as CUmemAllocationHandleType;
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_NONE: CUmemAccess_flags_enum = 0;
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_READ: CUmemAccess_flags_enum = 1;
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_READWRITE: CUmemAccess_flags_enum = 3;
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_MAX: CUmemAccess_flags_enum = 2147483647;
pub type CUmemAccess_flags_enum = ::std::os::raw::c_uint;
pub use self::CUmemAccess_flags_enum as CUmemAccess_flags;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_INVALID: CUmemLocationType_enum = 0;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_DEVICE: CUmemLocationType_enum = 1;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_MAX: CUmemLocationType_enum = 2147483647;
pub type CUmemLocationType_enum = ::std::os::raw::c_uint;
pub use self::CUmemLocationType_enum as CUmemLocationType;
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_INVALID: CUmemAllocationType_enum = 0;
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_PINNED: CUmemAllocationType_enum = 1;
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_MAX: CUmemAllocationType_enum =
    2147483647;
pub type CUmemAllocationType_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationType_enum as CUmemAllocationType;
pub const CUmemAllocationGranularity_flags_enum_CU_MEM_ALLOC_GRANULARITY_MINIMUM:
    CUmemAllocationGranularity_flags_enum = 0;
pub const CUmemAllocationGranularity_flags_enum_CU_MEM_ALLOC_GRANULARITY_RECOMMENDED:
    CUmemAllocationGranularity_flags_enum = 1;
pub type CUmemAllocationGranularity_flags_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationGranularity_flags_enum as CUmemAllocationGranularity_flags;
pub const CUmemRangeHandleType_enum_CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD: CUmemRangeHandleType_enum =
    1;
pub const CUmemRangeHandleType_enum_CU_MEM_RANGE_HANDLE_TYPE_MAX: CUmemRangeHandleType_enum =
    2147483647;
pub type CUmemRangeHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUmemRangeHandleType_enum as CUmemRangeHandleType;
pub const CUarraySparseSubresourceType_enum_CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL:
    CUarraySparseSubresourceType_enum = 0;
pub const CUarraySparseSubresourceType_enum_CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL:
    CUarraySparseSubresourceType_enum = 1;
pub type CUarraySparseSubresourceType_enum = ::std::os::raw::c_uint;
pub use self::CUarraySparseSubresourceType_enum as CUarraySparseSubresourceType;
pub const CUmemOperationType_enum_CU_MEM_OPERATION_TYPE_MAP: CUmemOperationType_enum = 1;
pub const CUmemOperationType_enum_CU_MEM_OPERATION_TYPE_UNMAP: CUmemOperationType_enum = 2;
pub type CUmemOperationType_enum = ::std::os::raw::c_uint;
pub use self::CUmemOperationType_enum as CUmemOperationType;
pub const CUmemHandleType_enum_CU_MEM_HANDLE_TYPE_GENERIC: CUmemHandleType_enum = 0;
pub type CUmemHandleType_enum = ::std::os::raw::c_uint;
pub use self::CUmemHandleType_enum as CUmemHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUarrayMapInfo_st {
    pub resourceType: CUresourcetype,
    pub resource: CUarrayMapInfo_st__bindgen_ty_1,
    pub subresourceType: CUarraySparseSubresourceType,
    pub subresource: CUarrayMapInfo_st__bindgen_ty_2,
    pub memOperationType: CUmemOperationType,
    pub memHandleType: CUmemHandleType,
    pub memHandle: CUarrayMapInfo_st__bindgen_ty_3,
    pub offset: ::std::os::raw::c_ulonglong,
    pub deviceBitMask: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_1 {
    pub mipmap: CUmipmappedArray,
    pub array: CUarray,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_1),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_2 {
    pub sparseLevel: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1,
    pub miptail: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 {
    pub level: ::std::os::raw::c_uint,
    pub layer: ::std::os::raw::c_uint,
    pub offsetX: ::std::os::raw::c_uint,
    pub offsetY: ::std::os::raw::c_uint,
    pub offsetZ: ::std::os::raw::c_uint,
    pub extentWidth: ::std::os::raw::c_uint,
    pub extentHeight: ::std::os::raw::c_uint,
    pub extentDepth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    fn test_field_level() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(level)
            )
        );
    }
    test_field_level();
    fn test_field_layer() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(layer)
            )
        );
    }
    test_field_layer();
    fn test_field_offsetX() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetX) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(offsetX)
            )
        );
    }
    test_field_offsetX();
    fn test_field_offsetY() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetY) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(offsetY)
            )
        );
    }
    test_field_offsetY();
    fn test_field_offsetZ() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offsetZ) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(offsetZ)
            )
        );
    }
    test_field_offsetZ();
    fn test_field_extentWidth() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extentWidth) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(extentWidth)
            )
        );
    }
    test_field_extentWidth();
    fn test_field_extentHeight() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extentHeight) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(extentHeight)
            )
        );
    }
    test_field_extentHeight();
    fn test_field_extentDepth() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extentDepth) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(extentDepth)
            )
        );
    }
    test_field_extentDepth();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 {
    pub layer: ::std::os::raw::c_uint,
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    fn test_field_layer() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(layer)
            )
        );
    }
    test_field_layer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    fn test_field_sparseLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseLevel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2),
                "::",
                stringify!(sparseLevel)
            )
        );
    }
    test_field_sparseLevel();
    fn test_field_miptail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptail) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_2),
                "::",
                stringify!(miptail)
            )
        );
    }
    test_field_miptail();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_3 {
    pub memHandle: CUmemGenericAllocationHandle,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    fn test_field_memHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st__bindgen_ty_3),
                "::",
                stringify!(memHandle)
            )
        );
    }
    test_field_memHandle();
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st>(),
        96usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st))
    );
    fn test_field_resourceType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(resourceType)
            )
        );
    }
    test_field_resourceType();
    fn test_field_resource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(resource)
            )
        );
    }
    test_field_resource();
    fn test_field_subresourceType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresourceType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(subresourceType)
            )
        );
    }
    test_field_subresourceType();
    fn test_field_subresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresource) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(subresource)
            )
        );
    }
    test_field_subresource();
    fn test_field_memOperationType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memOperationType) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(memOperationType)
            )
        );
    }
    test_field_memOperationType();
    fn test_field_memHandleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memHandleType) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(memHandleType)
            )
        );
    }
    test_field_memHandleType();
    fn test_field_memHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(memHandle)
            )
        );
    }
    test_field_memHandle();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_deviceBitMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceBitMask) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(deviceBitMask)
            )
        );
    }
    test_field_deviceBitMask();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUarrayMapInfo_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(CUarrayMapInfo_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUarrayMapInfo_v1 = CUarrayMapInfo_st;
pub type CUarrayMapInfo = CUarrayMapInfo_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemLocation_st {
    pub type_: CUmemLocationType,
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUmemLocation_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemLocation_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemLocation_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemLocation_st))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemLocation_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemLocation_st),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemLocation_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemLocation_st),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
pub type CUmemLocation_v1 = CUmemLocation_st;
pub type CUmemLocation = CUmemLocation_v1;
pub const CUmemAllocationCompType_enum_CU_MEM_ALLOCATION_COMP_NONE: CUmemAllocationCompType_enum =
    0;
pub const CUmemAllocationCompType_enum_CU_MEM_ALLOCATION_COMP_GENERIC:
    CUmemAllocationCompType_enum = 1;
pub type CUmemAllocationCompType_enum = ::std::os::raw::c_uint;
pub use self::CUmemAllocationCompType_enum as CUmemAllocationCompType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st {
    pub type_: CUmemAllocationType,
    pub requestedHandleTypes: CUmemAllocationHandleType,
    pub location: CUmemLocation,
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: CUmemAllocationProp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st__bindgen_ty_1 {
    pub compressionType: ::std::os::raw::c_uchar,
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    pub usage: ::std::os::raw::c_ushort,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    fn test_field_compressionType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUmemAllocationProp_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressionType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st__bindgen_ty_1),
                "::",
                stringify!(compressionType)
            )
        );
    }
    test_field_compressionType();
    fn test_field_gpuDirectRDMACapable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUmemAllocationProp_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gpuDirectRDMACapable) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st__bindgen_ty_1),
                "::",
                stringify!(gpuDirectRDMACapable)
            )
        );
    }
    test_field_gpuDirectRDMACapable();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUmemAllocationProp_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st__bindgen_ty_1),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<CUmemAllocationProp_st__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemAllocationProp_st))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAllocationProp_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_requestedHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAllocationProp_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requestedHandleTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st),
                "::",
                stringify!(requestedHandleTypes)
            )
        );
    }
    test_field_requestedHandleTypes();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAllocationProp_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_win32HandleMetaData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAllocationProp_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32HandleMetaData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st),
                "::",
                stringify!(win32HandleMetaData)
            )
        );
    }
    test_field_win32HandleMetaData();
    fn test_field_allocFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAllocationProp_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocFlags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAllocationProp_st),
                "::",
                stringify!(allocFlags)
            )
        );
    }
    test_field_allocFlags();
}
pub type CUmemAllocationProp_v1 = CUmemAllocationProp_st;
pub type CUmemAllocationProp = CUmemAllocationProp_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAccessDesc_st {
    pub location: CUmemLocation,
    pub flags: CUmemAccess_flags,
}
#[test]
fn bindgen_test_layout_CUmemAccessDesc_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemAccessDesc_st>(),
        12usize,
        concat!("Size of: ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAccessDesc_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemAccessDesc_st))
    );
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAccessDesc_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAccessDesc_st),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemAccessDesc_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemAccessDesc_st),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
pub type CUmemAccessDesc_v1 = CUmemAccessDesc_st;
pub type CUmemAccessDesc = CUmemAccessDesc_v1;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_SUCCESS: CUgraphExecUpdateResult_enum =
    0;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR: CUgraphExecUpdateResult_enum = 1;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED:
    CUgraphExecUpdateResult_enum = 2;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED:
    CUgraphExecUpdateResult_enum = 3;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED:
    CUgraphExecUpdateResult_enum = 4;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED:
    CUgraphExecUpdateResult_enum = 5;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED:
    CUgraphExecUpdateResult_enum = 6;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE:
    CUgraphExecUpdateResult_enum = 7;
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED:
    CUgraphExecUpdateResult_enum = 8;
pub type CUgraphExecUpdateResult_enum = ::std::os::raw::c_uint;
pub use self::CUgraphExecUpdateResult_enum as CUgraphExecUpdateResult;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES:
    CUmemPool_attribute_enum = 1;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC:
    CUmemPool_attribute_enum = 2;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES:
    CUmemPool_attribute_enum = 3;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: CUmemPool_attribute_enum = 4;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT: CUmemPool_attribute_enum =
    5;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: CUmemPool_attribute_enum = 6;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_USED_MEM_CURRENT: CUmemPool_attribute_enum = 7;
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_USED_MEM_HIGH: CUmemPool_attribute_enum = 8;
pub type CUmemPool_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUmemPool_attribute_enum as CUmemPool_attribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolProps_st {
    pub allocType: CUmemAllocationType,
    pub handleTypes: CUmemAllocationHandleType,
    pub location: CUmemLocation,
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolProps_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolProps_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolProps_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemPoolProps_st))
    );
    fn test_field_allocType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemPoolProps_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemPoolProps_st),
                "::",
                stringify!(allocType)
            )
        );
    }
    test_field_allocType();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemPoolProps_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemPoolProps_st),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemPoolProps_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemPoolProps_st),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_win32SecurityAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemPoolProps_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemPoolProps_st),
                "::",
                stringify!(win32SecurityAttributes)
            )
        );
    }
    test_field_win32SecurityAttributes();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemPoolProps_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemPoolProps_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUmemPoolProps_v1 = CUmemPoolProps_st;
pub type CUmemPoolProps = CUmemPoolProps_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolPtrExportData_st {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolPtrExportData_st() {
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolPtrExportData_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolPtrExportData_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUmemPoolPtrExportData_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUmemPoolPtrExportData_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUmemPoolPtrExportData_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type CUmemPoolPtrExportData_v1 = CUmemPoolPtrExportData_st;
pub type CUmemPoolPtrExportData = CUmemPoolPtrExportData_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_st {
    pub poolProps: CUmemPoolProps,
    pub accessDescs: *const CUmemAccessDesc,
    pub accessDescCount: size_t,
    pub bytesize: size_t,
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_ALLOC_NODE_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        120usize,
        concat!("Size of: ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    fn test_field_poolProps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEM_ALLOC_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
                "::",
                stringify!(poolProps)
            )
        );
    }
    test_field_poolProps();
    fn test_field_accessDescs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEM_ALLOC_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
                "::",
                stringify!(accessDescs)
            )
        );
    }
    test_field_accessDescs();
    fn test_field_accessDescCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEM_ALLOC_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
                "::",
                stringify!(accessDescCount)
            )
        );
    }
    test_field_accessDescCount();
    fn test_field_bytesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEM_ALLOC_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
                "::",
                stringify!(bytesize)
            )
        );
    }
    test_field_bytesize();
    fn test_field_dptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<CUDA_MEM_ALLOC_NODE_PARAMS_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
                "::",
                stringify!(dptr)
            )
        );
    }
    test_field_dptr();
}
pub type CUDA_MEM_ALLOC_NODE_PARAMS = CUDA_MEM_ALLOC_NODE_PARAMS_st;
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT: CUgraphMem_attribute_enum =
    0;
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: CUgraphMem_attribute_enum = 1;
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT:
    CUgraphMem_attribute_enum = 2;
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: CUgraphMem_attribute_enum =
    3;
pub type CUgraphMem_attribute_enum = ::std::os::raw::c_uint;
pub use self::CUgraphMem_attribute_enum as CUgraphMem_attribute;
pub const CUflushGPUDirectRDMAWritesOptions_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST:
    CUflushGPUDirectRDMAWritesOptions_enum = 1;
pub const CUflushGPUDirectRDMAWritesOptions_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS:
    CUflushGPUDirectRDMAWritesOptions_enum = 2;
pub type CUflushGPUDirectRDMAWritesOptions_enum = ::std::os::raw::c_uint;
pub use self::CUflushGPUDirectRDMAWritesOptions_enum as CUflushGPUDirectRDMAWritesOptions;
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE:
    CUGPUDirectRDMAWritesOrdering_enum = 0;
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER:
    CUGPUDirectRDMAWritesOrdering_enum = 100;
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES:
    CUGPUDirectRDMAWritesOrdering_enum = 200;
pub type CUGPUDirectRDMAWritesOrdering_enum = ::std::os::raw::c_uint;
pub use self::CUGPUDirectRDMAWritesOrdering_enum as CUGPUDirectRDMAWritesOrdering;
pub const CUflushGPUDirectRDMAWritesScope_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER:
    CUflushGPUDirectRDMAWritesScope_enum = 100;
pub const CUflushGPUDirectRDMAWritesScope_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES:
    CUflushGPUDirectRDMAWritesScope_enum = 200;
pub type CUflushGPUDirectRDMAWritesScope_enum = ::std::os::raw::c_uint;
pub use self::CUflushGPUDirectRDMAWritesScope_enum as CUflushGPUDirectRDMAWritesScope;
pub const CUflushGPUDirectRDMAWritesTarget_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX : CUflushGPUDirectRDMAWritesTarget_enum = 0 ;
pub type CUflushGPUDirectRDMAWritesTarget_enum = ::std::os::raw::c_uint;
pub use self::CUflushGPUDirectRDMAWritesTarget_enum as CUflushGPUDirectRDMAWritesTarget;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE: CUgraphDebugDot_flags_enum =
    1;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES:
    CUgraphDebugDot_flags_enum = 2;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 4;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 8;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 16;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 32;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 64;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 128;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 256;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES:
    CUgraphDebugDot_flags_enum = 512;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES: CUgraphDebugDot_flags_enum =
    1024;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 2048;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 4096;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 8192;
pub type CUgraphDebugDot_flags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphDebugDot_flags_enum as CUgraphDebugDot_flags;
pub const CUuserObject_flags_enum_CU_USER_OBJECT_NO_DESTRUCTOR_SYNC: CUuserObject_flags_enum = 1;
pub type CUuserObject_flags_enum = ::std::os::raw::c_uint;
pub use self::CUuserObject_flags_enum as CUuserObject_flags;
pub const CUuserObjectRetain_flags_enum_CU_GRAPH_USER_OBJECT_MOVE: CUuserObjectRetain_flags_enum =
    1;
pub type CUuserObjectRetain_flags_enum = ::std::os::raw::c_uint;
pub use self::CUuserObjectRetain_flags_enum as CUuserObjectRetain_flags;
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH:
    CUgraphInstantiate_flags_enum = 1;
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY:
    CUgraphInstantiate_flags_enum = 8;
pub type CUgraphInstantiate_flags_enum = ::std::os::raw::c_uint;
pub use self::CUgraphInstantiate_flags_enum as CUgraphInstantiate_flags;
extern "C" {
    pub fn cuGetErrorString(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    pub fn cuGetErrorName(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    pub fn cuInit(Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGet(device: *mut CUdevice, ordinal: ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetCount(count: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetUuid(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetUuid_v2(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetLuid(
        luid: *mut ::std::os::raw::c_char,
        deviceNodeMask: *mut ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceTotalMem_v2(bytes: *mut size_t, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut size_t,
        format: CUarray_format,
        numChannels: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::os::raw::c_void,
        dev: CUdevice,
        flags: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceSetMemPool(dev: CUdevice, pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetMemPool(pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetDefaultMemPool(pool_out: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuFlushGPUDirectRDMAWrites(
        target: CUflushGPUDirectRDMAWritesTarget,
        scope: CUflushGPUDirectRDMAWritesScope,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetProperties(prop: *mut CUdevprop, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxRetain(pctx: *mut CUcontext, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxRelease_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxSetFlags_v2(dev: CUdevice, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxGetState(
        dev: CUdevice,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxReset_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetExecAffinitySupport(
        pi: *mut ::std::os::raw::c_int,
        type_: CUexecAffinityType,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v2(
        pctx: *mut CUcontext,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v3(
        pctx: *mut CUcontext,
        paramsArray: *mut CUexecAffinityParam,
        numParams: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxDestroy_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPushCurrent_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPopCurrent_v2(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxSetCurrent(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetCurrent(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetDevice(device: *mut CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuCtxSynchronize() -> CUresult;
}
extern "C" {
    pub fn cuCtxSetLimit(limit: CUlimit, value: size_t) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetLimit(pvalue: *mut size_t, limit: CUlimit) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetCacheConfig(pconfig: *mut CUfunc_cache) -> CUresult;
}
extern "C" {
    pub fn cuCtxSetCacheConfig(config: CUfunc_cache) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetSharedMemConfig(pConfig: *mut CUsharedconfig) -> CUresult;
}
extern "C" {
    pub fn cuCtxSetSharedMemConfig(config: CUsharedconfig) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetApiVersion(ctx: CUcontext, version: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuCtxGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxResetPersistingL2Cache() -> CUresult;
}
extern "C" {
    pub fn cuCtxGetExecAffinity(
        pExecAffinity: *mut CUexecAffinityParam,
        type_: CUexecAffinityType,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxAttach(pctx: *mut CUcontext, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuCtxDetach(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoad(module: *mut CUmodule, fname: *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoadData(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoadDataEx(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleLoadFatBinary(
        module: *mut CUmodule,
        fatCubin: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleUnload(hmod: CUmodule) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetFunction(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetGlobal_v2(
        dptr: *mut CUdeviceptr,
        bytes: *mut size_t,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetTexRef(
        pTexRef: *mut CUtexref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetSurfRef(
        pSurfRef: *mut CUsurfref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkCreate_v2(
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddData_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::os::raw::c_void,
        size: size_t,
        name: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddFile_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        path: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkComplete(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::os::raw::c_void,
        sizeOut: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkDestroy(state: CUlinkState) -> CUresult;
}
extern "C" {
    pub fn cuMemGetInfo_v2(free: *mut size_t, total: *mut size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemAlloc_v2(dptr: *mut CUdeviceptr, bytesize: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocPitch_v2(
        dptr: *mut CUdeviceptr,
        pPitch: *mut size_t,
        WidthInBytes: size_t,
        Height: size_t,
        ElementSizeBytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemFree_v2(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAddressRange_v2(
        pbase: *mut CUdeviceptr,
        psize: *mut size_t,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocHost_v2(pp: *mut *mut ::std::os::raw::c_void, bytesize: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemFreeHost(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    pub fn cuMemHostAlloc(
        pp: *mut *mut ::std::os::raw::c_void,
        bytesize: size_t,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostGetDevicePointer_v2(
        pdptr: *mut CUdeviceptr,
        p: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        p: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocManaged(
        dptr: *mut CUdeviceptr,
        bytesize: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetByPCIBusId(
        dev: *mut CUdevice,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuIpcGetEventHandle(pHandle: *mut CUipcEventHandle, event: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuIpcOpenEventHandle(phEvent: *mut CUevent, handle: CUipcEventHandle) -> CUresult;
}
extern "C" {
    pub fn cuIpcGetMemHandle(pHandle: *mut CUipcMemHandle, dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuIpcOpenMemHandle_v2(
        pdptr: *mut CUdeviceptr,
        handle: CUipcMemHandle,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuIpcCloseMemHandle(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemHostRegister_v2(
        p: *mut ::std::os::raw::c_void,
        bytesize: size_t,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostUnregister(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy(dst: CUdeviceptr, src: CUdeviceptr, ByteCount: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyPeer(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoD_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoD_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoA_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoD_v2(
        dstDevice: CUdeviceptr,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoA_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoA_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2D_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DUnaligned_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3D_v2(pCopy: *const CUDA_MEMCPY3D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DPeer(pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAsync(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyPeerAsync(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoAAsync_v2(
        dstArray: CUarray,
        dstOffset: size_t,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: size_t,
        ByteCount: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DAsync_v2(pCopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DAsync_v2(pCopy: *const CUDA_MEMCPY3D, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DPeerAsync(pCopy: *const CUDA_MEMCPY3D_PEER, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD8_v2(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD16_v2(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD32_v2(
        dstDevice: CUdeviceptr,
        ui: ::std::os::raw::c_uint,
        N: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D8_v2(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        uc: ::std::os::raw::c_uchar,
        Width: size_t,
        Height: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D16_v2(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        us: ::std::os::raw::c_ushort,
        Width: size_t,
        Height: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D32_v2(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        ui: ::std::os::raw::c_uint,
        Width: size_t,
        Height: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD8Async(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD16Async(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD32Async(
        dstDevice: CUdeviceptr,
        ui: ::std::os::raw::c_uint,
        N: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D8Async(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        uc: ::std::os::raw::c_uchar,
        Width: size_t,
        Height: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D16Async(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        us: ::std::os::raw::c_ushort,
        Width: size_t,
        Height: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D32Async(
        dstDevice: CUdeviceptr,
        dstPitch: size_t,
        ui: ::std::os::raw::c_uint,
        Width: size_t,
        Height: size_t,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        array: CUarray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        mipmap: CUmipmappedArray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetMemoryRequirements(
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        array: CUarray,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayGetMemoryRequirements(
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        mipmap: CUmipmappedArray,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetPlane(
        pPlaneArray: *mut CUarray,
        hArray: CUarray,
        planeIdx: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayDestroy(hArray: CUarray) -> CUresult;
}
extern "C" {
    pub fn cuArray3DCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArray3DGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayCreate(
        pHandle: *mut CUmipmappedArray,
        pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayGetLevel(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMipmappedArrayDestroy(hMipmappedArray: CUmipmappedArray) -> CUresult;
}
extern "C" {
    pub fn cuMemAddressReserve(
        ptr: *mut CUdeviceptr,
        size: size_t,
        alignment: size_t,
        addr: CUdeviceptr,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAddressFree(ptr: CUdeviceptr, size: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemCreate(
        handle: *mut CUmemGenericAllocationHandle,
        size: size_t,
        prop: *const CUmemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRelease(handle: CUmemGenericAllocationHandle) -> CUresult;
}
extern "C" {
    pub fn cuMemMap(
        ptr: CUdeviceptr,
        size: size_t,
        offset: size_t,
        handle: CUmemGenericAllocationHandle,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemMapArrayAsync(
        mapInfoList: *mut CUarrayMapInfo,
        count: ::std::os::raw::c_uint,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemUnmap(ptr: CUdeviceptr, size: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemSetAccess(
        ptr: CUdeviceptr,
        size: size_t,
        desc: *const CUmemAccessDesc,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAccess(
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const CUmemLocation,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: CUmemGenericAllocationHandle,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemImportFromShareableHandle(
        handle: *mut CUmemGenericAllocationHandle,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: CUmemAllocationHandleType,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAllocationGranularity(
        granularity: *mut size_t,
        prop: *const CUmemAllocationProp,
        option: CUmemAllocationGranularity_flags,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAllocationPropertiesFromHandle(
        prop: *mut CUmemAllocationProp,
        handle: CUmemGenericAllocationHandle,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRetainAllocationHandle(
        handle: *mut CUmemGenericAllocationHandle,
        addr: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemFreeAsync(dptr: CUdeviceptr, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocAsync(dptr: *mut CUdeviceptr, bytesize: size_t, hStream: CUstream)
        -> CUresult;
}
extern "C" {
    pub fn cuMemPoolTrimTo(pool: CUmemoryPool, minBytesToKeep: size_t) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolSetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolGetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolSetAccess(
        pool: CUmemoryPool,
        map: *const CUmemAccessDesc,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolGetAccess(
        flags: *mut CUmemAccess_flags,
        memPool: CUmemoryPool,
        location: *mut CUmemLocation,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolCreate(pool: *mut CUmemoryPool, poolProps: *const CUmemPoolProps) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolDestroy(pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocFromPoolAsync(
        dptr: *mut CUdeviceptr,
        bytesize: size_t,
        pool: CUmemoryPool,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolExportToShareableHandle(
        handle_out: *mut ::std::os::raw::c_void,
        pool: CUmemoryPool,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolImportFromShareableHandle(
        pool_out: *mut CUmemoryPool,
        handle: *mut ::std::os::raw::c_void,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolExportPointer(
        shareData_out: *mut CUmemPoolPtrExportData,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPoolImportPointer(
        ptr_out: *mut CUdeviceptr,
        pool: CUmemoryPool,
        shareData: *mut CUmemPoolPtrExportData,
    ) -> CUresult;
}
extern "C" {
    pub fn cuPointerGetAttribute(
        data: *mut ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemPrefetchAsync(
        devPtr: CUdeviceptr,
        count: size_t,
        dstDevice: CUdevice,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAdvise(
        devPtr: CUdeviceptr,
        count: size_t,
        advice: CUmem_advise,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        dataSize: size_t,
        attribute: CUmem_range_attribute,
        devPtr: CUdeviceptr,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        dataSizes: *mut size_t,
        attributes: *mut CUmem_range_attribute,
        numAttributes: size_t,
        devPtr: CUdeviceptr,
        count: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuPointerSetAttribute(
        value: *const ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuPointerGetAttributes(
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut CUpointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamCreate(phStream: *mut CUstream, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuStreamCreateWithPriority(
        phStream: *mut CUstream,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetPriority(hStream: CUstream, priority: *mut ::std::os::raw::c_int)
        -> CUresult;
}
extern "C" {
    pub fn cuStreamGetFlags(hStream: CUstream, flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCtx(hStream: CUstream, pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitEvent(
        hStream: CUstream,
        hEvent: CUevent,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamAddCallback(
        hStream: CUstream,
        callback: CUstreamCallback,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBeginCapture_v2(hStream: CUstream, mode: CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    pub fn cuThreadExchangeStreamCaptureMode(mode: *mut CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    pub fn cuStreamEndCapture(hStream: CUstream, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuStreamIsCapturing(
        hStream: CUstream,
        captureStatus: *mut CUstreamCaptureStatus,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCaptureInfo(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCaptureInfo_v2(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        numDependencies_out: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamUpdateCaptureDependencies(
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        numDependencies: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamAttachMemAsync(
        hStream: CUstream,
        dptr: CUdeviceptr,
        length: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamQuery(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamSynchronize(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamDestroy_v2(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamCopyAttributes(dst: CUstream, src: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value_out: *mut CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamSetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value: *const CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuEventCreate(phEvent: *mut CUevent, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuEventRecord(hEvent: CUevent, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuEventRecordWithFlags(
        hEvent: CUevent,
        hStream: CUstream,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuEventQuery(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventSynchronize(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventDestroy_v2(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventElapsedTime(pMilliseconds: *mut f32, hStart: CUevent, hEnd: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuImportExternalMemory(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuExternalMemoryGetMappedBuffer(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDestroyExternalMemory(extMem: CUexternalMemory) -> CUresult;
}
extern "C" {
    pub fn cuImportExternalSemaphore(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSignalExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuWaitExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDestroyExternalSemaphore(extSem: CUexternalSemaphore) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue32(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue64(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue32(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue64(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBatchMemOp(
        stream: CUstream,
        count: ::std::os::raw::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue32_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue64_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue32_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue64_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBatchMemOp_v2(
        stream: CUstream,
        count: ::std::os::raw::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUfunction_attribute,
        hfunc: CUfunction,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetAttribute(
        hfunc: CUfunction,
        attrib: CUfunction_attribute,
        value: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetCacheConfig(hfunc: CUfunction, config: CUfunc_cache) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetSharedMemConfig(hfunc: CUfunction, config: CUsharedconfig) -> CUresult;
}
extern "C" {
    pub fn cuFuncGetModule(hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult;
}
extern "C" {
    pub fn cuLaunchKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchCooperativeKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut CUDA_LAUNCH_PARAMS,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchHostFunc(
        hStream: CUstream,
        fn_: CUhostFn,
        userData: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetBlockShape(
        hfunc: CUfunction,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuFuncSetSharedSize(hfunc: CUfunction, bytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuParamSetSize(hfunc: CUfunction, numbytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuParamSeti(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuParamSetf(hfunc: CUfunction, offset: ::std::os::raw::c_int, value: f32) -> CUresult;
}
extern "C" {
    pub fn cuParamSetv(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
        numbytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunch(f: CUfunction) -> CUresult;
}
extern "C" {
    pub fn cuLaunchGrid(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLaunchGridAsync(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuParamSetTexRef(
        hfunc: CUfunction,
        texunit: ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphCreate(phGraph: *mut CUgraph, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddKernelNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemcpyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemcpyNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemcpyNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemsetNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemsetNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemsetNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddHostNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphHostNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphHostNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddChildGraphNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphChildGraphNodeGetGraph(hNode: CUgraphNode, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddEmptyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddEventRecordNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventRecordNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventRecordNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddEventWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventWaitNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphEventWaitNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddExternalSemaphoresSignalNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresSignalNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresSignalNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddExternalSemaphoresWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresWaitNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExternalSemaphoresWaitNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddBatchMemOpNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphBatchMemOpNodeGetParams(
        hNode: CUgraphNode,
        nodeParams_out: *mut CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphBatchMemOpNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecBatchMemOpNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemAllocNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemAllocNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddMemFreeNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: size_t,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphMemFreeNodeGetParams(hNode: CUgraphNode, dptr_out: *mut CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGraphMemTrim(device: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceSetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphClone(phGraphClone: *mut CUgraph, originalGraph: CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeFindInClone(
        phNode: *mut CUgraphNode,
        hOriginalNode: CUgraphNode,
        hClonedGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetType(hNode: CUgraphNode, type_: *mut CUgraphNodeType) -> CUresult;
}
extern "C" {
    pub fn cuGraphGetNodes(
        hGraph: CUgraph,
        nodes: *mut CUgraphNode,
        numNodes: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphGetRootNodes(
        hGraph: CUgraph,
        rootNodes: *mut CUgraphNode,
        numRootNodes: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphGetEdges(
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        numEdges: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetDependencies(
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        numDependencies: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetDependentNodes(
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        numDependentNodes: *mut size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphRemoveDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphDestroyNode(hNode: CUgraphNode) -> CUresult;
}
extern "C" {
    pub fn cuGraphInstantiate_v2(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        phErrorNode: *mut CUgraphNode,
        logBuffer: *mut ::std::os::raw::c_char,
        bufferSize: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphInstantiateWithFlags(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecKernelNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecMemcpyNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecMemsetNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecHostNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecChildGraphNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecEventRecordNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecEventWaitNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeSetEnabled(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphNodeGetEnabled(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: *mut ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphUpload(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuGraphLaunch(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecDestroy(hGraphExec: CUgraphExec) -> CUresult;
}
extern "C" {
    pub fn cuGraphDestroy(hGraph: CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecUpdate(
        hGraphExec: CUgraphExec,
        hGraph: CUgraph,
        hErrorNode_out: *mut CUgraphNode,
        updateResult_out: *mut CUgraphExecUpdateResult,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeCopyAttributes(dst: CUgraphNode, src: CUgraphNode) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeGetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value_out: *mut CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeSetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value: *const CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphDebugDotPrint(
        hGraph: CUgraph,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuUserObjectCreate(
        object_out: *mut CUuserObject,
        ptr: *mut ::std::os::raw::c_void,
        destroy: CUhostFn,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuUserObjectRetain(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuUserObjectRelease(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuGraphRetainUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphReleaseUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxPotentialBlockSize(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: size_t,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyMaxPotentialBlockSizeWithFlags(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: size_t,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut size_t,
        func: CUfunction,
        numBlocks: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetArray(
        hTexRef: CUtexref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmappedArray(
        hTexRef: CUtexref,
        hMipmappedArray: CUmipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress_v2(
        ByteOffset: *mut size_t,
        hTexRef: CUtexref,
        dptr: CUdeviceptr,
        bytes: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress2D_v3(
        hTexRef: CUtexref,
        desc: *const CUDA_ARRAY_DESCRIPTOR,
        dptr: CUdeviceptr,
        Pitch: size_t,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetFormat(
        hTexRef: CUtexref,
        fmt: CUarray_format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddressMode(
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
        am: CUaddress_mode,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmapFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmapLevelBias(hTexRef: CUtexref, bias: f32) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMipmapLevelClamp(
        hTexRef: CUtexref,
        minMipmapLevelClamp: f32,
        maxMipmapLevelClamp: f32,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetMaxAnisotropy(
        hTexRef: CUtexref,
        maxAniso: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetBorderColor(hTexRef: CUtexref, pBorderColor: *mut f32) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetFlags(hTexRef: CUtexref, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetAddress_v2(pdptr: *mut CUdeviceptr, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetArray(phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmappedArray(
        phMipmappedArray: *mut CUmipmappedArray,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetAddressMode(
        pam: *mut CUaddress_mode,
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetFormat(
        pFormat: *mut CUarray_format,
        pNumChannels: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmapFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmapLevelBias(pbias: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetMaxAnisotropy(
        pmaxAniso: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetBorderColor(pBorderColor: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetFlags(pFlags: *mut ::std::os::raw::c_uint, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefCreate(pTexRef: *mut CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuTexRefDestroy(hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    pub fn cuSurfRefSetArray(
        hSurfRef: CUsurfref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSurfRefGetArray(phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectCreate(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectDestroy(texObject: CUtexObject) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectGetTextureDesc(
        pTexDesc: *mut CUDA_TEXTURE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexObjectGetResourceViewDesc(
        pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSurfObjectCreate(
        pSurfObject: *mut CUsurfObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
    ) -> CUresult;
}
extern "C" {
    pub fn cuSurfObjectDestroy(surfObject: CUsurfObject) -> CUresult;
}
extern "C" {
    pub fn cuSurfObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        surfObject: CUsurfObject,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        dev: CUdevice,
        peerDev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxEnablePeerAccess(peerContext: CUcontext, Flags: ::std::os::raw::c_uint)
        -> CUresult;
}
extern "C" {
    pub fn cuCtxDisablePeerAccess(peerContext: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: CUdevice_P2PAttribute,
        srcDevice: CUdevice,
        dstDevice: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsUnregisterResource(resource: CUgraphicsResource) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsSubResourceGetMappedArray(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceGetMappedMipmappedArray(
        pMipmappedArray: *mut CUmipmappedArray,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceGetMappedPointer_v2(
        pDevPtr: *mut CUdeviceptr,
        pSize: *mut size_t,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceSetMapFlags_v2(
        resource: CUgraphicsResource,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsMapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsUnmapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGetProcAddress(
        symbol: *const ::std::os::raw::c_char,
        pfn: *mut *mut ::std::os::raw::c_void,
        cudaVersion: ::std::os::raw::c_int,
        flags: cuuint64_t,
    ) -> CUresult;
}
pub const CUmoduleLoadingMode_enum_CU_MODULE_EAGER_LOADING: CUmoduleLoadingMode_enum = 1;
pub const CUmoduleLoadingMode_enum_CU_MODULE_LAZY_LOADING: CUmoduleLoadingMode_enum = 2;
pub type CUmoduleLoadingMode_enum = ::std::os::raw::c_uint;
pub use self::CUmoduleLoadingMode_enum as CUmoduleLoadingMode;
extern "C" {
    pub fn cuModuleGetLoadingMode(mode: *mut CUmoduleLoadingMode) -> CUresult;
}
extern "C" {
    pub fn cuMemGetHandleForAddressRange(
        handle: *mut ::std::os::raw::c_void,
        dptr: CUdeviceptr,
        size: size_t,
        handleType: CUmemRangeHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGetExportTable(
        ppExportTable: *mut *const ::std::os::raw::c_void,
        pExportTableId: *const CUuuid,
    ) -> CUresult;
}
pub const cudaRoundMode_cudaRoundNearest: cudaRoundMode = 0;
pub const cudaRoundMode_cudaRoundZero: cudaRoundMode = 1;
pub const cudaRoundMode_cudaRoundPosInf: cudaRoundMode = 2;
pub const cudaRoundMode_cudaRoundMinInf: cudaRoundMode = 3;
pub type cudaRoundMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char1 {
    pub x: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char1() {
    assert_eq!(
        ::std::mem::size_of::<char1>(),
        1usize,
        concat!("Size of: ", stringify!(char1))
    );
    assert_eq!(
        ::std::mem::align_of::<char1>(),
        1usize,
        concat!("Alignment of ", stringify!(char1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(char1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar1 {
    pub x: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar1() {
    assert_eq!(
        ::std::mem::size_of::<uchar1>(),
        1usize,
        concat!("Size of: ", stringify!(uchar1))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar1>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uchar1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct char2 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char2() {
    assert_eq!(
        ::std::mem::size_of::<char2>(),
        2usize,
        concat!("Size of: ", stringify!(char2))
    );
    assert_eq!(
        ::std::mem::align_of::<char2>(),
        2usize,
        concat!("Alignment of ", stringify!(char2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(char2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            1usize,
            concat!("Offset of field: ", stringify!(char2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct uchar2 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar2() {
    assert_eq!(
        ::std::mem::size_of::<uchar2>(),
        2usize,
        concat!("Size of: ", stringify!(uchar2))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar2>(),
        2usize,
        concat!("Alignment of ", stringify!(uchar2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            1usize,
            concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char3 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
    pub z: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char3() {
    assert_eq!(
        ::std::mem::size_of::<char3>(),
        3usize,
        concat!("Size of: ", stringify!(char3))
    );
    assert_eq!(
        ::std::mem::align_of::<char3>(),
        1usize,
        concat!("Alignment of ", stringify!(char3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(char3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            1usize,
            concat!("Offset of field: ", stringify!(char3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(char3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar3 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar3() {
    assert_eq!(
        ::std::mem::size_of::<uchar3>(),
        3usize,
        concat!("Size of: ", stringify!(uchar3))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar3>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            1usize,
            concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct char4 {
    pub x: ::std::os::raw::c_schar,
    pub y: ::std::os::raw::c_schar,
    pub z: ::std::os::raw::c_schar,
    pub w: ::std::os::raw::c_schar,
}
#[test]
fn bindgen_test_layout_char4() {
    assert_eq!(
        ::std::mem::size_of::<char4>(),
        4usize,
        concat!("Size of: ", stringify!(char4))
    );
    assert_eq!(
        ::std::mem::align_of::<char4>(),
        4usize,
        concat!("Alignment of ", stringify!(char4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(char4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            1usize,
            concat!("Offset of field: ", stringify!(char4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(char4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<char4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            3usize,
            concat!("Offset of field: ", stringify!(char4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uchar4 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
    pub w: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar4() {
    assert_eq!(
        ::std::mem::size_of::<uchar4>(),
        4usize,
        concat!("Size of: ", stringify!(uchar4))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar4>(),
        4usize,
        concat!("Alignment of ", stringify!(uchar4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            1usize,
            concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uchar4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            3usize,
            concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short1 {
    pub x: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short1() {
    assert_eq!(
        ::std::mem::size_of::<short1>(),
        2usize,
        concat!("Size of: ", stringify!(short1))
    );
    assert_eq!(
        ::std::mem::align_of::<short1>(),
        2usize,
        concat!("Alignment of ", stringify!(short1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(short1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort1 {
    pub x: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort1() {
    assert_eq!(
        ::std::mem::size_of::<ushort1>(),
        2usize,
        concat!("Size of: ", stringify!(ushort1))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort1>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct short2 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short2() {
    assert_eq!(
        ::std::mem::size_of::<short2>(),
        4usize,
        concat!("Size of: ", stringify!(short2))
    );
    assert_eq!(
        ::std::mem::align_of::<short2>(),
        4usize,
        concat!("Alignment of ", stringify!(short2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(short2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(short2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ushort2 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort2() {
    assert_eq!(
        ::std::mem::size_of::<ushort2>(),
        4usize,
        concat!("Size of: ", stringify!(ushort2))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort2>(),
        4usize,
        concat!("Alignment of ", stringify!(ushort2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort2),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort2),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short3 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short3() {
    assert_eq!(
        ::std::mem::size_of::<short3>(),
        6usize,
        concat!("Size of: ", stringify!(short3))
    );
    assert_eq!(
        ::std::mem::align_of::<short3>(),
        2usize,
        concat!("Alignment of ", stringify!(short3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(short3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(short3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(short3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort3 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort3() {
    assert_eq!(
        ::std::mem::size_of::<ushort3>(),
        6usize,
        concat!("Size of: ", stringify!(ushort3))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort3>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort3),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort3),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort3),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct short4 {
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub z: ::std::os::raw::c_short,
    pub w: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_short4() {
    assert_eq!(
        ::std::mem::size_of::<short4>(),
        8usize,
        concat!("Size of: ", stringify!(short4))
    );
    assert_eq!(
        ::std::mem::align_of::<short4>(),
        8usize,
        concat!("Alignment of ", stringify!(short4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(short4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            2usize,
            concat!("Offset of field: ", stringify!(short4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(short4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<short4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            6usize,
            concat!("Offset of field: ", stringify!(short4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ushort4 {
    pub x: ::std::os::raw::c_ushort,
    pub y: ::std::os::raw::c_ushort,
    pub z: ::std::os::raw::c_ushort,
    pub w: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort4() {
    assert_eq!(
        ::std::mem::size_of::<ushort4>(),
        8usize,
        concat!("Size of: ", stringify!(ushort4))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort4>(),
        8usize,
        concat!("Alignment of ", stringify!(ushort4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort4),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort4),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort4),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ushort4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(ushort4),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int1 {
    pub x: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int1() {
    assert_eq!(
        ::std::mem::size_of::<int1>(),
        4usize,
        concat!("Size of: ", stringify!(int1))
    );
    assert_eq!(
        ::std::mem::align_of::<int1>(),
        4usize,
        concat!("Alignment of ", stringify!(int1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(int1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint1 {
    pub x: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint1() {
    assert_eq!(
        ::std::mem::size_of::<uint1>(),
        4usize,
        concat!("Size of: ", stringify!(uint1))
    );
    assert_eq!(
        ::std::mem::align_of::<uint1>(),
        4usize,
        concat!("Alignment of ", stringify!(uint1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uint1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct int2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int2() {
    assert_eq!(
        ::std::mem::size_of::<int2>(),
        8usize,
        concat!("Size of: ", stringify!(int2))
    );
    assert_eq!(
        ::std::mem::align_of::<int2>(),
        8usize,
        concat!("Alignment of ", stringify!(int2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(int2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(int2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct uint2 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint2() {
    assert_eq!(
        ::std::mem::size_of::<uint2>(),
        8usize,
        concat!("Size of: ", stringify!(uint2))
    );
    assert_eq!(
        ::std::mem::align_of::<uint2>(),
        8usize,
        concat!("Alignment of ", stringify!(uint2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uint2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(uint2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int3() {
    assert_eq!(
        ::std::mem::size_of::<int3>(),
        12usize,
        concat!("Size of: ", stringify!(int3))
    );
    assert_eq!(
        ::std::mem::align_of::<int3>(),
        4usize,
        concat!("Alignment of ", stringify!(int3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(int3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(int3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(int3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint3() {
    assert_eq!(
        ::std::mem::size_of::<uint3>(),
        12usize,
        concat!("Size of: ", stringify!(uint3))
    );
    assert_eq!(
        ::std::mem::align_of::<uint3>(),
        4usize,
        concat!("Alignment of ", stringify!(uint3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uint3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(uint3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(uint3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct int4 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_int4() {
    assert_eq!(
        ::std::mem::size_of::<int4>(),
        16usize,
        concat!("Size of: ", stringify!(int4))
    );
    assert_eq!(
        ::std::mem::align_of::<int4>(),
        16usize,
        concat!("Alignment of ", stringify!(int4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(int4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(int4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(int4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<int4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(int4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct uint4 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
    pub w: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uint4() {
    assert_eq!(
        ::std::mem::size_of::<uint4>(),
        16usize,
        concat!("Size of: ", stringify!(uint4))
    );
    assert_eq!(
        ::std::mem::align_of::<uint4>(),
        16usize,
        concat!("Alignment of ", stringify!(uint4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(uint4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(uint4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(uint4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uint4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(uint4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long1 {
    pub x: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long1() {
    assert_eq!(
        ::std::mem::size_of::<long1>(),
        8usize,
        concat!("Size of: ", stringify!(long1))
    );
    assert_eq!(
        ::std::mem::align_of::<long1>(),
        8usize,
        concat!("Alignment of ", stringify!(long1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(long1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong1 {
    pub x: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong1() {
    assert_eq!(
        ::std::mem::size_of::<ulong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(ulong1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct long2 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long2() {
    assert_eq!(
        ::std::mem::size_of::<long2>(),
        16usize,
        concat!("Size of: ", stringify!(long2))
    );
    assert_eq!(
        ::std::mem::align_of::<long2>(),
        16usize,
        concat!("Alignment of ", stringify!(long2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(long2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(long2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulong2 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong2() {
    assert_eq!(
        ::std::mem::size_of::<ulong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong2>(),
        16usize,
        concat!("Alignment of ", stringify!(ulong2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long3 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long3() {
    assert_eq!(
        ::std::mem::size_of::<long3>(),
        24usize,
        concat!("Size of: ", stringify!(long3))
    );
    assert_eq!(
        ::std::mem::align_of::<long3>(),
        8usize,
        concat!("Alignment of ", stringify!(long3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(long3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(long3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(long3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong3 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong3() {
    assert_eq!(
        ::std::mem::size_of::<ulong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct long4 {
    pub x: ::std::os::raw::c_long,
    pub y: ::std::os::raw::c_long,
    pub z: ::std::os::raw::c_long,
    pub w: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_long4() {
    assert_eq!(
        ::std::mem::size_of::<long4>(),
        32usize,
        concat!("Size of: ", stringify!(long4))
    );
    assert_eq!(
        ::std::mem::align_of::<long4>(),
        16usize,
        concat!("Alignment of ", stringify!(long4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(long4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(long4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(long4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<long4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(long4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulong4 {
    pub x: ::std::os::raw::c_ulong,
    pub y: ::std::os::raw::c_ulong,
    pub z: ::std::os::raw::c_ulong,
    pub w: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong4() {
    assert_eq!(
        ::std::mem::size_of::<ulong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong4>(),
        16usize,
        concat!("Alignment of ", stringify!(ulong4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float1 {
    pub x: f32,
}
#[test]
fn bindgen_test_layout_float1() {
    assert_eq!(
        ::std::mem::size_of::<float1>(),
        4usize,
        concat!("Size of: ", stringify!(float1))
    );
    assert_eq!(
        ::std::mem::align_of::<float1>(),
        4usize,
        concat!("Alignment of ", stringify!(float1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(float1), "::", stringify!(x))
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        8usize,
        concat!("Alignment of ", stringify!(float2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_float3() {
    assert_eq!(
        ::std::mem::size_of::<float3>(),
        12usize,
        concat!("Size of: ", stringify!(float3))
    );
    assert_eq!(
        ::std::mem::align_of::<float3>(),
        4usize,
        concat!("Alignment of ", stringify!(float3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(float3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(float3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(float3), "::", stringify!(z))
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct float4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_float4() {
    assert_eq!(
        ::std::mem::size_of::<float4>(),
        16usize,
        concat!("Size of: ", stringify!(float4))
    );
    assert_eq!(
        ::std::mem::align_of::<float4>(),
        16usize,
        concat!("Alignment of ", stringify!(float4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(float4), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(float4), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(float4), "::", stringify!(z))
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<float4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(float4), "::", stringify!(w))
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong1 {
    pub x: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong1() {
    assert_eq!(
        ::std::mem::size_of::<longlong1>(),
        8usize,
        concat!("Size of: ", stringify!(longlong1))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong1>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong1 {
    pub x: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong1() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulonglong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct longlong2 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong2() {
    assert_eq!(
        ::std::mem::size_of::<longlong2>(),
        16usize,
        concat!("Size of: ", stringify!(longlong2))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong2>(),
        16usize,
        concat!("Alignment of ", stringify!(longlong2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong2),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong2),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong2 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong2() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulonglong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong2>(),
        16usize,
        concat!("Alignment of ", stringify!(ulonglong2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong2),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong2),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong3 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong3() {
    assert_eq!(
        ::std::mem::size_of::<longlong3>(),
        24usize,
        concat!("Size of: ", stringify!(longlong3))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong3>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong3),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong3),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong3),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong3 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong3() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulonglong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong3),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong3),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong3),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct longlong4 {
    pub x: ::std::os::raw::c_longlong,
    pub y: ::std::os::raw::c_longlong,
    pub z: ::std::os::raw::c_longlong,
    pub w: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong4() {
    assert_eq!(
        ::std::mem::size_of::<longlong4>(),
        32usize,
        concat!("Size of: ", stringify!(longlong4))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong4>(),
        16usize,
        concat!("Alignment of ", stringify!(longlong4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong4),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong4),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong4),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<longlong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(longlong4),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong4 {
    pub x: ::std::os::raw::c_ulonglong,
    pub y: ::std::os::raw::c_ulonglong,
    pub z: ::std::os::raw::c_ulonglong,
    pub w: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong4() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulonglong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong4>(),
        16usize,
        concat!("Alignment of ", stringify!(ulonglong4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong4),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong4),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong4),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ulonglong4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ulonglong4),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double1 {
    pub x: f64,
}
#[test]
fn bindgen_test_layout_double1() {
    assert_eq!(
        ::std::mem::size_of::<double1>(),
        8usize,
        concat!("Size of: ", stringify!(double1))
    );
    assert_eq!(
        ::std::mem::align_of::<double1>(),
        8usize,
        concat!("Alignment of ", stringify!(double1))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(double1),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        16usize,
        concat!("Alignment of ", stringify!(double2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(double2),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(double2),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_double3() {
    assert_eq!(
        ::std::mem::size_of::<double3>(),
        24usize,
        concat!("Size of: ", stringify!(double3))
    );
    assert_eq!(
        ::std::mem::align_of::<double3>(),
        8usize,
        concat!("Alignment of ", stringify!(double3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(double3),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(double3),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(double3),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct double4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_double4() {
    assert_eq!(
        ::std::mem::size_of::<double4>(),
        32usize,
        concat!("Size of: ", stringify!(double4))
    );
    assert_eq!(
        ::std::mem::align_of::<double4>(),
        16usize,
        concat!("Alignment of ", stringify!(double4))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(double4),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(double4),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(double4),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<double4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(double4),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_dim3() {
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dim3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
        );
    }
    test_field_z();
}
pub const cudaError_cudaSuccess: cudaError = 0;
pub const cudaError_cudaErrorInvalidValue: cudaError = 1;
pub const cudaError_cudaErrorMemoryAllocation: cudaError = 2;
pub const cudaError_cudaErrorInitializationError: cudaError = 3;
pub const cudaError_cudaErrorCudartUnloading: cudaError = 4;
pub const cudaError_cudaErrorProfilerDisabled: cudaError = 5;
pub const cudaError_cudaErrorProfilerNotInitialized: cudaError = 6;
pub const cudaError_cudaErrorProfilerAlreadyStarted: cudaError = 7;
pub const cudaError_cudaErrorProfilerAlreadyStopped: cudaError = 8;
pub const cudaError_cudaErrorInvalidConfiguration: cudaError = 9;
pub const cudaError_cudaErrorInvalidPitchValue: cudaError = 12;
pub const cudaError_cudaErrorInvalidSymbol: cudaError = 13;
pub const cudaError_cudaErrorInvalidHostPointer: cudaError = 16;
pub const cudaError_cudaErrorInvalidDevicePointer: cudaError = 17;
pub const cudaError_cudaErrorInvalidTexture: cudaError = 18;
pub const cudaError_cudaErrorInvalidTextureBinding: cudaError = 19;
pub const cudaError_cudaErrorInvalidChannelDescriptor: cudaError = 20;
pub const cudaError_cudaErrorInvalidMemcpyDirection: cudaError = 21;
pub const cudaError_cudaErrorAddressOfConstant: cudaError = 22;
pub const cudaError_cudaErrorTextureFetchFailed: cudaError = 23;
pub const cudaError_cudaErrorTextureNotBound: cudaError = 24;
pub const cudaError_cudaErrorSynchronizationError: cudaError = 25;
pub const cudaError_cudaErrorInvalidFilterSetting: cudaError = 26;
pub const cudaError_cudaErrorInvalidNormSetting: cudaError = 27;
pub const cudaError_cudaErrorMixedDeviceExecution: cudaError = 28;
pub const cudaError_cudaErrorNotYetImplemented: cudaError = 31;
pub const cudaError_cudaErrorMemoryValueTooLarge: cudaError = 32;
pub const cudaError_cudaErrorStubLibrary: cudaError = 34;
pub const cudaError_cudaErrorInsufficientDriver: cudaError = 35;
pub const cudaError_cudaErrorCallRequiresNewerDriver: cudaError = 36;
pub const cudaError_cudaErrorInvalidSurface: cudaError = 37;
pub const cudaError_cudaErrorDuplicateVariableName: cudaError = 43;
pub const cudaError_cudaErrorDuplicateTextureName: cudaError = 44;
pub const cudaError_cudaErrorDuplicateSurfaceName: cudaError = 45;
pub const cudaError_cudaErrorDevicesUnavailable: cudaError = 46;
pub const cudaError_cudaErrorIncompatibleDriverContext: cudaError = 49;
pub const cudaError_cudaErrorMissingConfiguration: cudaError = 52;
pub const cudaError_cudaErrorPriorLaunchFailure: cudaError = 53;
pub const cudaError_cudaErrorLaunchMaxDepthExceeded: cudaError = 65;
pub const cudaError_cudaErrorLaunchFileScopedTex: cudaError = 66;
pub const cudaError_cudaErrorLaunchFileScopedSurf: cudaError = 67;
pub const cudaError_cudaErrorSyncDepthExceeded: cudaError = 68;
pub const cudaError_cudaErrorLaunchPendingCountExceeded: cudaError = 69;
pub const cudaError_cudaErrorInvalidDeviceFunction: cudaError = 98;
pub const cudaError_cudaErrorNoDevice: cudaError = 100;
pub const cudaError_cudaErrorInvalidDevice: cudaError = 101;
pub const cudaError_cudaErrorDeviceNotLicensed: cudaError = 102;
pub const cudaError_cudaErrorSoftwareValidityNotEstablished: cudaError = 103;
pub const cudaError_cudaErrorStartupFailure: cudaError = 127;
pub const cudaError_cudaErrorInvalidKernelImage: cudaError = 200;
pub const cudaError_cudaErrorDeviceUninitialized: cudaError = 201;
pub const cudaError_cudaErrorMapBufferObjectFailed: cudaError = 205;
pub const cudaError_cudaErrorUnmapBufferObjectFailed: cudaError = 206;
pub const cudaError_cudaErrorArrayIsMapped: cudaError = 207;
pub const cudaError_cudaErrorAlreadyMapped: cudaError = 208;
pub const cudaError_cudaErrorNoKernelImageForDevice: cudaError = 209;
pub const cudaError_cudaErrorAlreadyAcquired: cudaError = 210;
pub const cudaError_cudaErrorNotMapped: cudaError = 211;
pub const cudaError_cudaErrorNotMappedAsArray: cudaError = 212;
pub const cudaError_cudaErrorNotMappedAsPointer: cudaError = 213;
pub const cudaError_cudaErrorECCUncorrectable: cudaError = 214;
pub const cudaError_cudaErrorUnsupportedLimit: cudaError = 215;
pub const cudaError_cudaErrorDeviceAlreadyInUse: cudaError = 216;
pub const cudaError_cudaErrorPeerAccessUnsupported: cudaError = 217;
pub const cudaError_cudaErrorInvalidPtx: cudaError = 218;
pub const cudaError_cudaErrorInvalidGraphicsContext: cudaError = 219;
pub const cudaError_cudaErrorNvlinkUncorrectable: cudaError = 220;
pub const cudaError_cudaErrorJitCompilerNotFound: cudaError = 221;
pub const cudaError_cudaErrorUnsupportedPtxVersion: cudaError = 222;
pub const cudaError_cudaErrorJitCompilationDisabled: cudaError = 223;
pub const cudaError_cudaErrorUnsupportedExecAffinity: cudaError = 224;
pub const cudaError_cudaErrorInvalidSource: cudaError = 300;
pub const cudaError_cudaErrorFileNotFound: cudaError = 301;
pub const cudaError_cudaErrorSharedObjectSymbolNotFound: cudaError = 302;
pub const cudaError_cudaErrorSharedObjectInitFailed: cudaError = 303;
pub const cudaError_cudaErrorOperatingSystem: cudaError = 304;
pub const cudaError_cudaErrorInvalidResourceHandle: cudaError = 400;
pub const cudaError_cudaErrorIllegalState: cudaError = 401;
pub const cudaError_cudaErrorSymbolNotFound: cudaError = 500;
pub const cudaError_cudaErrorNotReady: cudaError = 600;
pub const cudaError_cudaErrorIllegalAddress: cudaError = 700;
pub const cudaError_cudaErrorLaunchOutOfResources: cudaError = 701;
pub const cudaError_cudaErrorLaunchTimeout: cudaError = 702;
pub const cudaError_cudaErrorLaunchIncompatibleTexturing: cudaError = 703;
pub const cudaError_cudaErrorPeerAccessAlreadyEnabled: cudaError = 704;
pub const cudaError_cudaErrorPeerAccessNotEnabled: cudaError = 705;
pub const cudaError_cudaErrorSetOnActiveProcess: cudaError = 708;
pub const cudaError_cudaErrorContextIsDestroyed: cudaError = 709;
pub const cudaError_cudaErrorAssert: cudaError = 710;
pub const cudaError_cudaErrorTooManyPeers: cudaError = 711;
pub const cudaError_cudaErrorHostMemoryAlreadyRegistered: cudaError = 712;
pub const cudaError_cudaErrorHostMemoryNotRegistered: cudaError = 713;
pub const cudaError_cudaErrorHardwareStackError: cudaError = 714;
pub const cudaError_cudaErrorIllegalInstruction: cudaError = 715;
pub const cudaError_cudaErrorMisalignedAddress: cudaError = 716;
pub const cudaError_cudaErrorInvalidAddressSpace: cudaError = 717;
pub const cudaError_cudaErrorInvalidPc: cudaError = 718;
pub const cudaError_cudaErrorLaunchFailure: cudaError = 719;
pub const cudaError_cudaErrorCooperativeLaunchTooLarge: cudaError = 720;
pub const cudaError_cudaErrorNotPermitted: cudaError = 800;
pub const cudaError_cudaErrorNotSupported: cudaError = 801;
pub const cudaError_cudaErrorSystemNotReady: cudaError = 802;
pub const cudaError_cudaErrorSystemDriverMismatch: cudaError = 803;
pub const cudaError_cudaErrorCompatNotSupportedOnDevice: cudaError = 804;
pub const cudaError_cudaErrorMpsConnectionFailed: cudaError = 805;
pub const cudaError_cudaErrorMpsRpcFailure: cudaError = 806;
pub const cudaError_cudaErrorMpsServerNotReady: cudaError = 807;
pub const cudaError_cudaErrorMpsMaxClientsReached: cudaError = 808;
pub const cudaError_cudaErrorMpsMaxConnectionsReached: cudaError = 809;
pub const cudaError_cudaErrorStreamCaptureUnsupported: cudaError = 900;
pub const cudaError_cudaErrorStreamCaptureInvalidated: cudaError = 901;
pub const cudaError_cudaErrorStreamCaptureMerge: cudaError = 902;
pub const cudaError_cudaErrorStreamCaptureUnmatched: cudaError = 903;
pub const cudaError_cudaErrorStreamCaptureUnjoined: cudaError = 904;
pub const cudaError_cudaErrorStreamCaptureIsolation: cudaError = 905;
pub const cudaError_cudaErrorStreamCaptureImplicit: cudaError = 906;
pub const cudaError_cudaErrorCapturedEvent: cudaError = 907;
pub const cudaError_cudaErrorStreamCaptureWrongThread: cudaError = 908;
pub const cudaError_cudaErrorTimeout: cudaError = 909;
pub const cudaError_cudaErrorGraphExecUpdateFailure: cudaError = 910;
pub const cudaError_cudaErrorExternalDevice: cudaError = 911;
pub const cudaError_cudaErrorUnknown: cudaError = 999;
pub const cudaError_cudaErrorApiFailureBase: cudaError = 10000;
pub type cudaError = ::std::os::raw::c_uint;
pub const cudaChannelFormatKind_cudaChannelFormatKindSigned: cudaChannelFormatKind = 0;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsigned: cudaChannelFormatKind = 1;
pub const cudaChannelFormatKind_cudaChannelFormatKindFloat: cudaChannelFormatKind = 2;
pub const cudaChannelFormatKind_cudaChannelFormatKindNone: cudaChannelFormatKind = 3;
pub const cudaChannelFormatKind_cudaChannelFormatKindNV12: cudaChannelFormatKind = 4;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X1: cudaChannelFormatKind =
    5;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X2: cudaChannelFormatKind =
    6;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X4: cudaChannelFormatKind =
    7;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X1: cudaChannelFormatKind =
    8;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X2: cudaChannelFormatKind =
    9;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X4: cudaChannelFormatKind =
    10;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X1: cudaChannelFormatKind =
    11;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X2: cudaChannelFormatKind =
    12;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X4: cudaChannelFormatKind =
    13;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X1: cudaChannelFormatKind =
    14;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X2: cudaChannelFormatKind =
    15;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X4: cudaChannelFormatKind =
    16;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed1:
    cudaChannelFormatKind = 17;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed1SRGB:
    cudaChannelFormatKind = 18;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed2:
    cudaChannelFormatKind = 19;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed2SRGB:
    cudaChannelFormatKind = 20;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed3:
    cudaChannelFormatKind = 21;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed3SRGB:
    cudaChannelFormatKind = 22;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed4:
    cudaChannelFormatKind = 23;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed4: cudaChannelFormatKind =
    24;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed5:
    cudaChannelFormatKind = 25;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed5: cudaChannelFormatKind =
    26;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed6H:
    cudaChannelFormatKind = 27;
pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed6H:
    cudaChannelFormatKind = 28;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed7:
    cudaChannelFormatKind = 29;
pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed7SRGB:
    cudaChannelFormatKind = 30;
pub type cudaChannelFormatKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaChannelFormatDesc {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub f: cudaChannelFormatKind,
}
#[test]
fn bindgen_test_layout_cudaChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(cudaChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaChannelFormatDesc))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaChannelFormatDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaChannelFormatDesc),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArray {
    _unused: [u8; 0],
}
pub type cudaArray_t = *mut cudaArray;
pub type cudaArray_const_t = *const cudaArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMipmappedArray {
    _unused: [u8; 0],
}
pub type cudaMipmappedArray_t = *mut cudaMipmappedArray;
pub type cudaMipmappedArray_const_t = *const cudaMipmappedArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties {
    pub tileExtent: cudaArraySparseProperties__bindgen_ty_1,
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    pub miptailSize: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArraySparseProperties__bindgen_ty_1 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cudaArraySparseProperties__bindgen_ty_1)
        )
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaArraySparseProperties__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties__bindgen_ty_1),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[test]
fn bindgen_test_layout_cudaArraySparseProperties() {
    assert_eq!(
        ::std::mem::size_of::<cudaArraySparseProperties>(),
        48usize,
        concat!("Size of: ", stringify!(cudaArraySparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArraySparseProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArraySparseProperties))
    );
    fn test_field_tileExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(tileExtent)
            )
        );
    }
    test_field_tileExtent();
    fn test_field_miptailFirstLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(miptailFirstLevel)
            )
        );
    }
    test_field_miptailFirstLevel();
    fn test_field_miptailSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(miptailSize)
            )
        );
    }
    test_field_miptailSize();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArraySparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArraySparseProperties),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaArrayMemoryRequirements {
    pub size: size_t,
    pub alignment: size_t,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_cudaArrayMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<cudaArrayMemoryRequirements>(),
        32usize,
        concat!("Size of: ", stringify!(cudaArrayMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaArrayMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaArrayMemoryRequirements))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaArrayMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaArrayMemoryRequirements),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub const cudaMemoryType_cudaMemoryTypeUnregistered: cudaMemoryType = 0;
pub const cudaMemoryType_cudaMemoryTypeHost: cudaMemoryType = 1;
pub const cudaMemoryType_cudaMemoryTypeDevice: cudaMemoryType = 2;
pub const cudaMemoryType_cudaMemoryTypeManaged: cudaMemoryType = 3;
pub type cudaMemoryType = ::std::os::raw::c_uint;
pub const cudaMemcpyKind_cudaMemcpyHostToHost: cudaMemcpyKind = 0;
pub const cudaMemcpyKind_cudaMemcpyHostToDevice: cudaMemcpyKind = 1;
pub const cudaMemcpyKind_cudaMemcpyDeviceToHost: cudaMemcpyKind = 2;
pub const cudaMemcpyKind_cudaMemcpyDeviceToDevice: cudaMemcpyKind = 3;
pub const cudaMemcpyKind_cudaMemcpyDefault: cudaMemcpyKind = 4;
pub type cudaMemcpyKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPitchedPtr {
    pub ptr: *mut ::std::os::raw::c_void,
    pub pitch: size_t,
    pub xsize: size_t,
    pub ysize: size_t,
}
#[test]
fn bindgen_test_layout_cudaPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<cudaPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(cudaPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPitchedPtr))
    );
    fn test_field_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(ptr)
            )
        );
    }
    test_field_ptr();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_xsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(xsize)
            )
        );
    }
    test_field_xsize();
    fn test_field_ysize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPitchedPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPitchedPtr),
                "::",
                stringify!(ysize)
            )
        );
    }
    test_field_ysize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExtent {
    pub width: size_t,
    pub height: size_t,
    pub depth: size_t,
}
#[test]
fn bindgen_test_layout_cudaExtent() {
    assert_eq!(
        ::std::mem::size_of::<cudaExtent>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExtent))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExtent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExtent),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPos {
    pub x: size_t,
    pub y: size_t,
    pub z: size_t,
}
#[test]
fn bindgen_test_layout_cudaPos() {
    assert_eq!(
        ::std::mem::size_of::<cudaPos>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPos))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPos>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPos))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPos),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DParms {
    pub srcArray: cudaArray_t,
    pub srcPos: cudaPos,
    pub srcPtr: cudaPitchedPtr,
    pub dstArray: cudaArray_t,
    pub dstPos: cudaPos,
    pub dstPtr: cudaPitchedPtr,
    pub extent: cudaExtent,
    pub kind: cudaMemcpyKind,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DParms))
    );
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcPos)
            )
        );
    }
    test_field_srcPos();
    fn test_field_srcPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(srcPtr)
            )
        );
    }
    test_field_srcPtr();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstPos)
            )
        );
    }
    test_field_dstPos();
    fn test_field_dstPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(dstPtr)
            )
        );
    }
    test_field_dstPtr();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DParms),
                "::",
                stringify!(kind)
            )
        );
    }
    test_field_kind();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemcpy3DPeerParms {
    pub srcArray: cudaArray_t,
    pub srcPos: cudaPos,
    pub srcPtr: cudaPitchedPtr,
    pub srcDevice: ::std::os::raw::c_int,
    pub dstArray: cudaArray_t,
    pub dstPos: cudaPos,
    pub dstPtr: cudaPitchedPtr,
    pub dstDevice: ::std::os::raw::c_int,
    pub extent: cudaExtent,
}
#[test]
fn bindgen_test_layout_cudaMemcpy3DPeerParms() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemcpy3DPeerParms>(),
        168usize,
        concat!("Size of: ", stringify!(cudaMemcpy3DPeerParms))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemcpy3DPeerParms>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemcpy3DPeerParms))
    );
    fn test_field_srcArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcArray)
            )
        );
    }
    test_field_srcArray();
    fn test_field_srcPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcPos)
            )
        );
    }
    test_field_srcPos();
    fn test_field_srcPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcPtr)
            )
        );
    }
    test_field_srcPtr();
    fn test_field_srcDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(srcDevice)
            )
        );
    }
    test_field_srcDevice();
    fn test_field_dstArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstArray)
            )
        );
    }
    test_field_dstArray();
    fn test_field_dstPos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstPos)
            )
        );
    }
    test_field_dstPos();
    fn test_field_dstPtr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstPtr)
            )
        );
    }
    test_field_dstPtr();
    fn test_field_dstDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(dstDevice)
            )
        );
    }
    test_field_dstDevice();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemcpy3DPeerParms>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemcpy3DPeerParms),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemsetParams {
    pub dst: *mut ::std::os::raw::c_void,
    pub pitch: size_t,
    pub value: ::std::os::raw::c_uint,
    pub elementSize: ::std::os::raw::c_uint,
    pub width: size_t,
    pub height: size_t,
}
#[test]
fn bindgen_test_layout_cudaMemsetParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemsetParams>(),
        40usize,
        concat!("Size of: ", stringify!(cudaMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemsetParams))
    );
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_pitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(pitch)
            )
        );
    }
    test_field_pitch();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_elementSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(elementSize)
            )
        );
    }
    test_field_elementSize();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemsetParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemsetParams),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
pub const cudaAccessProperty_cudaAccessPropertyNormal: cudaAccessProperty = 0;
pub const cudaAccessProperty_cudaAccessPropertyStreaming: cudaAccessProperty = 1;
pub const cudaAccessProperty_cudaAccessPropertyPersisting: cudaAccessProperty = 2;
pub type cudaAccessProperty = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaAccessPolicyWindow {
    pub base_ptr: *mut ::std::os::raw::c_void,
    pub num_bytes: size_t,
    pub hitRatio: f32,
    pub hitProp: cudaAccessProperty,
    pub missProp: cudaAccessProperty,
}
#[test]
fn bindgen_test_layout_cudaAccessPolicyWindow() {
    assert_eq!(
        ::std::mem::size_of::<cudaAccessPolicyWindow>(),
        32usize,
        concat!("Size of: ", stringify!(cudaAccessPolicyWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaAccessPolicyWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaAccessPolicyWindow))
    );
    fn test_field_base_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(base_ptr)
            )
        );
    }
    test_field_base_ptr();
    fn test_field_num_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(num_bytes)
            )
        );
    }
    test_field_num_bytes();
    fn test_field_hitRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(hitRatio)
            )
        );
    }
    test_field_hitRatio();
    fn test_field_hitProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(hitProp)
            )
        );
    }
    test_field_hitProp();
    fn test_field_missProp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaAccessPolicyWindow>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaAccessPolicyWindow),
                "::",
                stringify!(missProp)
            )
        );
    }
    test_field_missProp();
}
pub type cudaHostFn_t =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaHostNodeParams {
    pub fn_: cudaHostFn_t,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaHostNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(cudaHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaHostNodeParams))
    );
    fn test_field_fn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaHostNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaHostNodeParams),
                "::",
                stringify!(fn_)
            )
        );
    }
    test_field_fn();
    fn test_field_userData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaHostNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaHostNodeParams),
                "::",
                stringify!(userData)
            )
        );
    }
    test_field_userData();
}
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusNone: cudaStreamCaptureStatus = 0;
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusActive: cudaStreamCaptureStatus = 1;
pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusInvalidated: cudaStreamCaptureStatus = 2;
pub type cudaStreamCaptureStatus = ::std::os::raw::c_uint;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeGlobal: cudaStreamCaptureMode = 0;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeThreadLocal: cudaStreamCaptureMode = 1;
pub const cudaStreamCaptureMode_cudaStreamCaptureModeRelaxed: cudaStreamCaptureMode = 2;
pub type cudaStreamCaptureMode = ::std::os::raw::c_uint;
pub const cudaSynchronizationPolicy_cudaSyncPolicyAuto: cudaSynchronizationPolicy = 1;
pub const cudaSynchronizationPolicy_cudaSyncPolicySpin: cudaSynchronizationPolicy = 2;
pub const cudaSynchronizationPolicy_cudaSyncPolicyYield: cudaSynchronizationPolicy = 3;
pub const cudaSynchronizationPolicy_cudaSyncPolicyBlockingSync: cudaSynchronizationPolicy = 4;
pub type cudaSynchronizationPolicy = ::std::os::raw::c_uint;
pub const cudaStreamUpdateCaptureDependenciesFlags_cudaStreamAddCaptureDependencies:
    cudaStreamUpdateCaptureDependenciesFlags = 0;
pub const cudaStreamUpdateCaptureDependenciesFlags_cudaStreamSetCaptureDependencies:
    cudaStreamUpdateCaptureDependenciesFlags = 1;
pub type cudaStreamUpdateCaptureDependenciesFlags = ::std::os::raw::c_uint;
pub const cudaUserObjectFlags_cudaUserObjectNoDestructorSync: cudaUserObjectFlags = 1;
pub type cudaUserObjectFlags = ::std::os::raw::c_uint;
pub const cudaUserObjectRetainFlags_cudaGraphUserObjectMove: cudaUserObjectRetainFlags = 1;
pub type cudaUserObjectRetainFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaGraphicsResource {
    _unused: [u8; 0],
}
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsNone: cudaGraphicsRegisterFlags = 0;
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsReadOnly: cudaGraphicsRegisterFlags =
    1;
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsWriteDiscard:
    cudaGraphicsRegisterFlags = 2;
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsSurfaceLoadStore:
    cudaGraphicsRegisterFlags = 4;
pub const cudaGraphicsRegisterFlags_cudaGraphicsRegisterFlagsTextureGather:
    cudaGraphicsRegisterFlags = 8;
pub type cudaGraphicsRegisterFlags = ::std::os::raw::c_uint;
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsNone: cudaGraphicsMapFlags = 0;
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsReadOnly: cudaGraphicsMapFlags = 1;
pub const cudaGraphicsMapFlags_cudaGraphicsMapFlagsWriteDiscard: cudaGraphicsMapFlags = 2;
pub type cudaGraphicsMapFlags = ::std::os::raw::c_uint;
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveX: cudaGraphicsCubeFace = 0;
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeX: cudaGraphicsCubeFace = 1;
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveY: cudaGraphicsCubeFace = 2;
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeY: cudaGraphicsCubeFace = 3;
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFacePositiveZ: cudaGraphicsCubeFace = 4;
pub const cudaGraphicsCubeFace_cudaGraphicsCubeFaceNegativeZ: cudaGraphicsCubeFace = 5;
pub type cudaGraphicsCubeFace = ::std::os::raw::c_uint;
pub const cudaResourceType_cudaResourceTypeArray: cudaResourceType = 0;
pub const cudaResourceType_cudaResourceTypeMipmappedArray: cudaResourceType = 1;
pub const cudaResourceType_cudaResourceTypeLinear: cudaResourceType = 2;
pub const cudaResourceType_cudaResourceTypePitch2D: cudaResourceType = 3;
pub type cudaResourceType = ::std::os::raw::c_uint;
pub const cudaResourceViewFormat_cudaResViewFormatNone: cudaResourceViewFormat = 0;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar1: cudaResourceViewFormat = 1;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar2: cudaResourceViewFormat = 2;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar4: cudaResourceViewFormat = 3;
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar1: cudaResourceViewFormat = 4;
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar2: cudaResourceViewFormat = 5;
pub const cudaResourceViewFormat_cudaResViewFormatSignedChar4: cudaResourceViewFormat = 6;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort1: cudaResourceViewFormat = 7;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort2: cudaResourceViewFormat = 8;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort4: cudaResourceViewFormat = 9;
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort1: cudaResourceViewFormat = 10;
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort2: cudaResourceViewFormat = 11;
pub const cudaResourceViewFormat_cudaResViewFormatSignedShort4: cudaResourceViewFormat = 12;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt1: cudaResourceViewFormat = 13;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt2: cudaResourceViewFormat = 14;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt4: cudaResourceViewFormat = 15;
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt1: cudaResourceViewFormat = 16;
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt2: cudaResourceViewFormat = 17;
pub const cudaResourceViewFormat_cudaResViewFormatSignedInt4: cudaResourceViewFormat = 18;
pub const cudaResourceViewFormat_cudaResViewFormatHalf1: cudaResourceViewFormat = 19;
pub const cudaResourceViewFormat_cudaResViewFormatHalf2: cudaResourceViewFormat = 20;
pub const cudaResourceViewFormat_cudaResViewFormatHalf4: cudaResourceViewFormat = 21;
pub const cudaResourceViewFormat_cudaResViewFormatFloat1: cudaResourceViewFormat = 22;
pub const cudaResourceViewFormat_cudaResViewFormatFloat2: cudaResourceViewFormat = 23;
pub const cudaResourceViewFormat_cudaResViewFormatFloat4: cudaResourceViewFormat = 24;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed1: cudaResourceViewFormat =
    25;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed2: cudaResourceViewFormat =
    26;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed3: cudaResourceViewFormat =
    27;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed4: cudaResourceViewFormat =
    28;
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed4: cudaResourceViewFormat =
    29;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed5: cudaResourceViewFormat =
    30;
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed5: cudaResourceViewFormat =
    31;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed6H:
    cudaResourceViewFormat = 32;
pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed6H: cudaResourceViewFormat =
    33;
pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed7: cudaResourceViewFormat =
    34;
pub type cudaResourceViewFormat = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaResourceDesc {
    pub resType: cudaResourceType,
    pub res: cudaResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaResourceDesc__bindgen_ty_1 {
    pub array: cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: cudaArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: cudaMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: cudaChannelFormatDesc,
    pub sizeInBytes: size_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_sizeInBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_3>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(sizeInBytes)
            )
        );
    }
    test_field_sizeInBytes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::std::os::raw::c_void,
    pub desc: cudaChannelFormatDesc,
    pub width: size_t,
    pub height: size_t,
    pub pitchInBytes: size_t,
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_devPtr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(devPtr)
            )
        );
    }
    test_field_devPtr();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_pitchInBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1__bindgen_ty_4>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(pitchInBytes)
            )
        );
    }
    test_field_pitchInBytes();
}
#[test]
fn bindgen_test_layout_cudaResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc__bindgen_ty_1))
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_mipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(mipmap)
            )
        );
    }
    test_field_mipmap();
    fn test_field_linear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(linear)
            )
        );
    }
    test_field_linear();
    fn test_field_pitch2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc__bindgen_ty_1),
                "::",
                stringify!(pitch2D)
            )
        );
    }
    test_field_pitch2D();
}
#[test]
fn bindgen_test_layout_cudaResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(cudaResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceDesc))
    );
    fn test_field_resType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc),
                "::",
                stringify!(resType)
            )
        );
    }
    test_field_resType();
    fn test_field_res() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceDesc),
                "::",
                stringify!(res)
            )
        );
    }
    test_field_res();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaResourceViewDesc {
    pub format: cudaResourceViewFormat,
    pub width: size_t,
    pub height: size_t,
    pub depth: size_t,
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    pub firstLayer: ::std::os::raw::c_uint,
    pub lastLayer: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(cudaResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaResourceViewDesc))
    );
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_firstMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(firstMipmapLevel)
            )
        );
    }
    test_field_firstMipmapLevel();
    fn test_field_lastMipmapLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(lastMipmapLevel)
            )
        );
    }
    test_field_lastMipmapLevel();
    fn test_field_firstLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(firstLayer)
            )
        );
    }
    test_field_firstLayer();
    fn test_field_lastLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaResourceViewDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaResourceViewDesc),
                "::",
                stringify!(lastLayer)
            )
        );
    }
    test_field_lastLayer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaPointerAttributes {
    pub type_: cudaMemoryType,
    pub device: ::std::os::raw::c_int,
    pub devicePointer: *mut ::std::os::raw::c_void,
    pub hostPointer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaPointerAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaPointerAttributes>(),
        24usize,
        concat!("Size of: ", stringify!(cudaPointerAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaPointerAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaPointerAttributes))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_device() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(device)
            )
        );
    }
    test_field_device();
    fn test_field_devicePointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).devicePointer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(devicePointer)
            )
        );
    }
    test_field_devicePointer();
    fn test_field_hostPointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaPointerAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostPointer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaPointerAttributes),
                "::",
                stringify!(hostPointer)
            )
        );
    }
    test_field_hostPointer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaFuncAttributes {
    pub sharedSizeBytes: size_t,
    pub constSizeBytes: size_t,
    pub localSizeBytes: size_t,
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub numRegs: ::std::os::raw::c_int,
    pub ptxVersion: ::std::os::raw::c_int,
    pub binaryVersion: ::std::os::raw::c_int,
    pub cacheModeCA: ::std::os::raw::c_int,
    pub maxDynamicSharedSizeBytes: ::std::os::raw::c_int,
    pub preferredShmemCarveout: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<cudaFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(cudaFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaFuncAttributes))
    );
    fn test_field_sharedSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedSizeBytes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(sharedSizeBytes)
            )
        );
    }
    test_field_sharedSizeBytes();
    fn test_field_constSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).constSizeBytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(constSizeBytes)
            )
        );
    }
    test_field_constSizeBytes();
    fn test_field_localSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localSizeBytes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(localSizeBytes)
            )
        );
    }
    test_field_localSizeBytes();
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_numRegs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numRegs) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(numRegs)
            )
        );
    }
    test_field_numRegs();
    fn test_field_ptxVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptxVersion) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(ptxVersion)
            )
        );
    }
    test_field_ptxVersion();
    fn test_field_binaryVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binaryVersion) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(binaryVersion)
            )
        );
    }
    test_field_binaryVersion();
    fn test_field_cacheModeCA() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cacheModeCA) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(cacheModeCA)
            )
        );
    }
    test_field_cacheModeCA();
    fn test_field_maxDynamicSharedSizeBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDynamicSharedSizeBytes) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(maxDynamicSharedSizeBytes)
            )
        );
    }
    test_field_maxDynamicSharedSizeBytes();
    fn test_field_preferredShmemCarveout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaFuncAttributes>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preferredShmemCarveout) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaFuncAttributes),
                "::",
                stringify!(preferredShmemCarveout)
            )
        );
    }
    test_field_preferredShmemCarveout();
}
pub const cudaFuncAttribute_cudaFuncAttributeMaxDynamicSharedMemorySize: cudaFuncAttribute = 8;
pub const cudaFuncAttribute_cudaFuncAttributePreferredSharedMemoryCarveout: cudaFuncAttribute = 9;
pub const cudaFuncAttribute_cudaFuncAttributeMax: cudaFuncAttribute = 10;
pub type cudaFuncAttribute = ::std::os::raw::c_uint;
pub const cudaFuncCache_cudaFuncCachePreferNone: cudaFuncCache = 0;
pub const cudaFuncCache_cudaFuncCachePreferShared: cudaFuncCache = 1;
pub const cudaFuncCache_cudaFuncCachePreferL1: cudaFuncCache = 2;
pub const cudaFuncCache_cudaFuncCachePreferEqual: cudaFuncCache = 3;
pub type cudaFuncCache = ::std::os::raw::c_uint;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeDefault: cudaSharedMemConfig = 0;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeFourByte: cudaSharedMemConfig = 1;
pub const cudaSharedMemConfig_cudaSharedMemBankSizeEightByte: cudaSharedMemConfig = 2;
pub type cudaSharedMemConfig = ::std::os::raw::c_uint;
pub const cudaSharedCarveout_cudaSharedmemCarveoutDefault: cudaSharedCarveout = -1;
pub const cudaSharedCarveout_cudaSharedmemCarveoutMaxShared: cudaSharedCarveout = 100;
pub const cudaSharedCarveout_cudaSharedmemCarveoutMaxL1: cudaSharedCarveout = 0;
pub type cudaSharedCarveout = ::std::os::raw::c_int;
pub const cudaComputeMode_cudaComputeModeDefault: cudaComputeMode = 0;
pub const cudaComputeMode_cudaComputeModeExclusive: cudaComputeMode = 1;
pub const cudaComputeMode_cudaComputeModeProhibited: cudaComputeMode = 2;
pub const cudaComputeMode_cudaComputeModeExclusiveProcess: cudaComputeMode = 3;
pub type cudaComputeMode = ::std::os::raw::c_uint;
pub const cudaLimit_cudaLimitStackSize: cudaLimit = 0;
pub const cudaLimit_cudaLimitPrintfFifoSize: cudaLimit = 1;
pub const cudaLimit_cudaLimitMallocHeapSize: cudaLimit = 2;
pub const cudaLimit_cudaLimitDevRuntimeSyncDepth: cudaLimit = 3;
pub const cudaLimit_cudaLimitDevRuntimePendingLaunchCount: cudaLimit = 4;
pub const cudaLimit_cudaLimitMaxL2FetchGranularity: cudaLimit = 5;
pub const cudaLimit_cudaLimitPersistingL2CacheSize: cudaLimit = 6;
pub type cudaLimit = ::std::os::raw::c_uint;
pub const cudaMemoryAdvise_cudaMemAdviseSetReadMostly: cudaMemoryAdvise = 1;
pub const cudaMemoryAdvise_cudaMemAdviseUnsetReadMostly: cudaMemoryAdvise = 2;
pub const cudaMemoryAdvise_cudaMemAdviseSetPreferredLocation: cudaMemoryAdvise = 3;
pub const cudaMemoryAdvise_cudaMemAdviseUnsetPreferredLocation: cudaMemoryAdvise = 4;
pub const cudaMemoryAdvise_cudaMemAdviseSetAccessedBy: cudaMemoryAdvise = 5;
pub const cudaMemoryAdvise_cudaMemAdviseUnsetAccessedBy: cudaMemoryAdvise = 6;
pub type cudaMemoryAdvise = ::std::os::raw::c_uint;
pub const cudaMemRangeAttribute_cudaMemRangeAttributeReadMostly: cudaMemRangeAttribute = 1;
pub const cudaMemRangeAttribute_cudaMemRangeAttributePreferredLocation: cudaMemRangeAttribute = 2;
pub const cudaMemRangeAttribute_cudaMemRangeAttributeAccessedBy: cudaMemRangeAttribute = 3;
pub const cudaMemRangeAttribute_cudaMemRangeAttributeLastPrefetchLocation: cudaMemRangeAttribute =
    4;
pub type cudaMemRangeAttribute = ::std::os::raw::c_uint;
pub const cudaOutputMode_cudaKeyValuePair: cudaOutputMode = 0;
pub const cudaOutputMode_cudaCSV: cudaOutputMode = 1;
pub type cudaOutputMode = ::std::os::raw::c_uint;
pub const cudaFlushGPUDirectRDMAWritesOptions_cudaFlushGPUDirectRDMAWritesOptionHost:
    cudaFlushGPUDirectRDMAWritesOptions = 1;
pub const cudaFlushGPUDirectRDMAWritesOptions_cudaFlushGPUDirectRDMAWritesOptionMemOps:
    cudaFlushGPUDirectRDMAWritesOptions = 2;
pub type cudaFlushGPUDirectRDMAWritesOptions = ::std::os::raw::c_uint;
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingNone:
    cudaGPUDirectRDMAWritesOrdering = 0;
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingOwner:
    cudaGPUDirectRDMAWritesOrdering = 100;
pub const cudaGPUDirectRDMAWritesOrdering_cudaGPUDirectRDMAWritesOrderingAllDevices:
    cudaGPUDirectRDMAWritesOrdering = 200;
pub type cudaGPUDirectRDMAWritesOrdering = ::std::os::raw::c_uint;
pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToOwner:
    cudaFlushGPUDirectRDMAWritesScope = 100;
pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToAllDevices:
    cudaFlushGPUDirectRDMAWritesScope = 200;
pub type cudaFlushGPUDirectRDMAWritesScope = ::std::os::raw::c_uint;
pub const cudaFlushGPUDirectRDMAWritesTarget_cudaFlushGPUDirectRDMAWritesTargetCurrentDevice:
    cudaFlushGPUDirectRDMAWritesTarget = 0;
pub type cudaFlushGPUDirectRDMAWritesTarget = ::std::os::raw::c_uint;
pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerBlock: cudaDeviceAttr = 1;
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimX: cudaDeviceAttr = 2;
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimY: cudaDeviceAttr = 3;
pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimZ: cudaDeviceAttr = 4;
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimX: cudaDeviceAttr = 5;
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimY: cudaDeviceAttr = 6;
pub const cudaDeviceAttr_cudaDevAttrMaxGridDimZ: cudaDeviceAttr = 7;
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlock: cudaDeviceAttr = 8;
pub const cudaDeviceAttr_cudaDevAttrTotalConstantMemory: cudaDeviceAttr = 9;
pub const cudaDeviceAttr_cudaDevAttrWarpSize: cudaDeviceAttr = 10;
pub const cudaDeviceAttr_cudaDevAttrMaxPitch: cudaDeviceAttr = 11;
pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerBlock: cudaDeviceAttr = 12;
pub const cudaDeviceAttr_cudaDevAttrClockRate: cudaDeviceAttr = 13;
pub const cudaDeviceAttr_cudaDevAttrTextureAlignment: cudaDeviceAttr = 14;
pub const cudaDeviceAttr_cudaDevAttrGpuOverlap: cudaDeviceAttr = 15;
pub const cudaDeviceAttr_cudaDevAttrMultiProcessorCount: cudaDeviceAttr = 16;
pub const cudaDeviceAttr_cudaDevAttrKernelExecTimeout: cudaDeviceAttr = 17;
pub const cudaDeviceAttr_cudaDevAttrIntegrated: cudaDeviceAttr = 18;
pub const cudaDeviceAttr_cudaDevAttrCanMapHostMemory: cudaDeviceAttr = 19;
pub const cudaDeviceAttr_cudaDevAttrComputeMode: cudaDeviceAttr = 20;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DWidth: cudaDeviceAttr = 21;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DWidth: cudaDeviceAttr = 22;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DHeight: cudaDeviceAttr = 23;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidth: cudaDeviceAttr = 24;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeight: cudaDeviceAttr = 25;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepth: cudaDeviceAttr = 26;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredWidth: cudaDeviceAttr = 27;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredHeight: cudaDeviceAttr = 28;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredLayers: cudaDeviceAttr = 29;
pub const cudaDeviceAttr_cudaDevAttrSurfaceAlignment: cudaDeviceAttr = 30;
pub const cudaDeviceAttr_cudaDevAttrConcurrentKernels: cudaDeviceAttr = 31;
pub const cudaDeviceAttr_cudaDevAttrEccEnabled: cudaDeviceAttr = 32;
pub const cudaDeviceAttr_cudaDevAttrPciBusId: cudaDeviceAttr = 33;
pub const cudaDeviceAttr_cudaDevAttrPciDeviceId: cudaDeviceAttr = 34;
pub const cudaDeviceAttr_cudaDevAttrTccDriver: cudaDeviceAttr = 35;
pub const cudaDeviceAttr_cudaDevAttrMemoryClockRate: cudaDeviceAttr = 36;
pub const cudaDeviceAttr_cudaDevAttrGlobalMemoryBusWidth: cudaDeviceAttr = 37;
pub const cudaDeviceAttr_cudaDevAttrL2CacheSize: cudaDeviceAttr = 38;
pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerMultiProcessor: cudaDeviceAttr = 39;
pub const cudaDeviceAttr_cudaDevAttrAsyncEngineCount: cudaDeviceAttr = 40;
pub const cudaDeviceAttr_cudaDevAttrUnifiedAddressing: cudaDeviceAttr = 41;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredWidth: cudaDeviceAttr = 42;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredLayers: cudaDeviceAttr = 43;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherWidth: cudaDeviceAttr = 45;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherHeight: cudaDeviceAttr = 46;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidthAlt: cudaDeviceAttr = 47;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeightAlt: cudaDeviceAttr = 48;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepthAlt: cudaDeviceAttr = 49;
pub const cudaDeviceAttr_cudaDevAttrPciDomainId: cudaDeviceAttr = 50;
pub const cudaDeviceAttr_cudaDevAttrTexturePitchAlignment: cudaDeviceAttr = 51;
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapWidth: cudaDeviceAttr = 52;
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredWidth: cudaDeviceAttr = 53;
pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredLayers: cudaDeviceAttr = 54;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DWidth: cudaDeviceAttr = 55;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DWidth: cudaDeviceAttr = 56;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DHeight: cudaDeviceAttr = 57;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DWidth: cudaDeviceAttr = 58;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DHeight: cudaDeviceAttr = 59;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DDepth: cudaDeviceAttr = 60;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredWidth: cudaDeviceAttr = 61;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredLayers: cudaDeviceAttr = 62;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredWidth: cudaDeviceAttr = 63;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredHeight: cudaDeviceAttr = 64;
pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredLayers: cudaDeviceAttr = 65;
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapWidth: cudaDeviceAttr = 66;
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredWidth: cudaDeviceAttr = 67;
pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredLayers: cudaDeviceAttr = 68;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLinearWidth: cudaDeviceAttr = 69;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearWidth: cudaDeviceAttr = 70;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearHeight: cudaDeviceAttr = 71;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearPitch: cudaDeviceAttr = 72;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedWidth: cudaDeviceAttr = 73;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedHeight: cudaDeviceAttr = 74;
pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMajor: cudaDeviceAttr = 75;
pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMinor: cudaDeviceAttr = 76;
pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DMipmappedWidth: cudaDeviceAttr = 77;
pub const cudaDeviceAttr_cudaDevAttrStreamPrioritiesSupported: cudaDeviceAttr = 78;
pub const cudaDeviceAttr_cudaDevAttrGlobalL1CacheSupported: cudaDeviceAttr = 79;
pub const cudaDeviceAttr_cudaDevAttrLocalL1CacheSupported: cudaDeviceAttr = 80;
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerMultiprocessor: cudaDeviceAttr = 81;
pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerMultiprocessor: cudaDeviceAttr = 82;
pub const cudaDeviceAttr_cudaDevAttrManagedMemory: cudaDeviceAttr = 83;
pub const cudaDeviceAttr_cudaDevAttrIsMultiGpuBoard: cudaDeviceAttr = 84;
pub const cudaDeviceAttr_cudaDevAttrMultiGpuBoardGroupID: cudaDeviceAttr = 85;
pub const cudaDeviceAttr_cudaDevAttrHostNativeAtomicSupported: cudaDeviceAttr = 86;
pub const cudaDeviceAttr_cudaDevAttrSingleToDoublePrecisionPerfRatio: cudaDeviceAttr = 87;
pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccess: cudaDeviceAttr = 88;
pub const cudaDeviceAttr_cudaDevAttrConcurrentManagedAccess: cudaDeviceAttr = 89;
pub const cudaDeviceAttr_cudaDevAttrComputePreemptionSupported: cudaDeviceAttr = 90;
pub const cudaDeviceAttr_cudaDevAttrCanUseHostPointerForRegisteredMem: cudaDeviceAttr = 91;
pub const cudaDeviceAttr_cudaDevAttrReserved92: cudaDeviceAttr = 92;
pub const cudaDeviceAttr_cudaDevAttrReserved93: cudaDeviceAttr = 93;
pub const cudaDeviceAttr_cudaDevAttrReserved94: cudaDeviceAttr = 94;
pub const cudaDeviceAttr_cudaDevAttrCooperativeLaunch: cudaDeviceAttr = 95;
pub const cudaDeviceAttr_cudaDevAttrCooperativeMultiDeviceLaunch: cudaDeviceAttr = 96;
pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlockOptin: cudaDeviceAttr = 97;
pub const cudaDeviceAttr_cudaDevAttrCanFlushRemoteWrites: cudaDeviceAttr = 98;
pub const cudaDeviceAttr_cudaDevAttrHostRegisterSupported: cudaDeviceAttr = 99;
pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccessUsesHostPageTables: cudaDeviceAttr = 100;
pub const cudaDeviceAttr_cudaDevAttrDirectManagedMemAccessFromHost: cudaDeviceAttr = 101;
pub const cudaDeviceAttr_cudaDevAttrMaxBlocksPerMultiprocessor: cudaDeviceAttr = 106;
pub const cudaDeviceAttr_cudaDevAttrMaxPersistingL2CacheSize: cudaDeviceAttr = 108;
pub const cudaDeviceAttr_cudaDevAttrMaxAccessPolicyWindowSize: cudaDeviceAttr = 109;
pub const cudaDeviceAttr_cudaDevAttrReservedSharedMemoryPerBlock: cudaDeviceAttr = 111;
pub const cudaDeviceAttr_cudaDevAttrSparseCudaArraySupported: cudaDeviceAttr = 112;
pub const cudaDeviceAttr_cudaDevAttrHostRegisterReadOnlySupported: cudaDeviceAttr = 113;
pub const cudaDeviceAttr_cudaDevAttrTimelineSemaphoreInteropSupported: cudaDeviceAttr = 114;
pub const cudaDeviceAttr_cudaDevAttrMaxTimelineSemaphoreInteropSupported: cudaDeviceAttr = 114;
pub const cudaDeviceAttr_cudaDevAttrMemoryPoolsSupported: cudaDeviceAttr = 115;
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMASupported: cudaDeviceAttr = 116;
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAFlushWritesOptions: cudaDeviceAttr = 117;
pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAWritesOrdering: cudaDeviceAttr = 118;
pub const cudaDeviceAttr_cudaDevAttrMemoryPoolSupportedHandleTypes: cudaDeviceAttr = 119;
pub const cudaDeviceAttr_cudaDevAttrDeferredMappingCudaArraySupported: cudaDeviceAttr = 121;
pub const cudaDeviceAttr_cudaDevAttrMax: cudaDeviceAttr = 122;
pub type cudaDeviceAttr = ::std::os::raw::c_uint;
pub const cudaMemPoolAttr_cudaMemPoolReuseFollowEventDependencies: cudaMemPoolAttr = 1;
pub const cudaMemPoolAttr_cudaMemPoolReuseAllowOpportunistic: cudaMemPoolAttr = 2;
pub const cudaMemPoolAttr_cudaMemPoolReuseAllowInternalDependencies: cudaMemPoolAttr = 3;
pub const cudaMemPoolAttr_cudaMemPoolAttrReleaseThreshold: cudaMemPoolAttr = 4;
pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemCurrent: cudaMemPoolAttr = 5;
pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemHigh: cudaMemPoolAttr = 6;
pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemCurrent: cudaMemPoolAttr = 7;
pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemHigh: cudaMemPoolAttr = 8;
pub type cudaMemPoolAttr = ::std::os::raw::c_uint;
pub const cudaMemLocationType_cudaMemLocationTypeInvalid: cudaMemLocationType = 0;
pub const cudaMemLocationType_cudaMemLocationTypeDevice: cudaMemLocationType = 1;
pub type cudaMemLocationType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemLocation {
    pub type_: cudaMemLocationType,
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaMemLocation() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemLocation>(),
        8usize,
        concat!("Size of: ", stringify!(cudaMemLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemLocation))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemLocation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemLocation),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemLocation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemLocation),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtNone: cudaMemAccessFlags = 0;
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtRead: cudaMemAccessFlags = 1;
pub const cudaMemAccessFlags_cudaMemAccessFlagsProtReadWrite: cudaMemAccessFlags = 3;
pub type cudaMemAccessFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAccessDesc {
    pub location: cudaMemLocation,
    pub flags: cudaMemAccessFlags,
}
#[test]
fn bindgen_test_layout_cudaMemAccessDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAccessDesc>(),
        12usize,
        concat!("Size of: ", stringify!(cudaMemAccessDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAccessDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaMemAccessDesc))
    );
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAccessDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAccessDesc),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAccessDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAccessDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
pub const cudaMemAllocationType_cudaMemAllocationTypeInvalid: cudaMemAllocationType = 0;
pub const cudaMemAllocationType_cudaMemAllocationTypePinned: cudaMemAllocationType = 1;
pub const cudaMemAllocationType_cudaMemAllocationTypeMax: cudaMemAllocationType = 2147483647;
pub type cudaMemAllocationType = ::std::os::raw::c_uint;
pub const cudaMemAllocationHandleType_cudaMemHandleTypeNone: cudaMemAllocationHandleType = 0;
pub const cudaMemAllocationHandleType_cudaMemHandleTypePosixFileDescriptor:
    cudaMemAllocationHandleType = 1;
pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32: cudaMemAllocationHandleType = 2;
pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32Kmt: cudaMemAllocationHandleType = 4;
pub type cudaMemAllocationHandleType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolProps {
    pub allocType: cudaMemAllocationType,
    pub handleTypes: cudaMemAllocationHandleType,
    pub location: cudaMemLocation,
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolProps() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolProps>(),
        88usize,
        concat!("Size of: ", stringify!(cudaMemPoolProps))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolProps>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemPoolProps))
    );
    fn test_field_allocType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(allocType)
            )
        );
    }
    test_field_allocType();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_win32SecurityAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(win32SecurityAttributes)
            )
        );
    }
    test_field_win32SecurityAttributes();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolProps>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolProps),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemPoolPtrExportData {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cudaMemPoolPtrExportData() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemPoolPtrExportData>(),
        64usize,
        concat!("Size of: ", stringify!(cudaMemPoolPtrExportData))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemPoolPtrExportData>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaMemPoolPtrExportData))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemPoolPtrExportData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemPoolPtrExportData),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaMemAllocNodeParams {
    pub poolProps: cudaMemPoolProps,
    pub accessDescs: *const cudaMemAccessDesc,
    pub accessDescCount: size_t,
    pub bytesize: size_t,
    pub dptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaMemAllocNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaMemAllocNodeParams>(),
        120usize,
        concat!("Size of: ", stringify!(cudaMemAllocNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaMemAllocNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaMemAllocNodeParams))
    );
    fn test_field_poolProps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(poolProps)
            )
        );
    }
    test_field_poolProps();
    fn test_field_accessDescs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(accessDescs)
            )
        );
    }
    test_field_accessDescs();
    fn test_field_accessDescCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(accessDescCount)
            )
        );
    }
    test_field_accessDescCount();
    fn test_field_bytesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(bytesize)
            )
        );
    }
    test_field_bytesize();
    fn test_field_dptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaMemAllocNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaMemAllocNodeParams),
                "::",
                stringify!(dptr)
            )
        );
    }
    test_field_dptr();
}
pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemCurrent: cudaGraphMemAttributeType = 0;
pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemHigh: cudaGraphMemAttributeType = 1;
pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemCurrent: cudaGraphMemAttributeType =
    2;
pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemHigh: cudaGraphMemAttributeType = 3;
pub type cudaGraphMemAttributeType = ::std::os::raw::c_uint;
pub const cudaDeviceP2PAttr_cudaDevP2PAttrPerformanceRank: cudaDeviceP2PAttr = 1;
pub const cudaDeviceP2PAttr_cudaDevP2PAttrAccessSupported: cudaDeviceP2PAttr = 2;
pub const cudaDeviceP2PAttr_cudaDevP2PAttrNativeAtomicSupported: cudaDeviceP2PAttr = 3;
pub const cudaDeviceP2PAttr_cudaDevP2PAttrCudaArrayAccessSupported: cudaDeviceP2PAttr = 4;
pub type cudaDeviceP2PAttr = ::std::os::raw::c_uint;
pub type cudaUUID_t = CUuuid_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaDeviceProp {
    pub name: [::std::os::raw::c_char; 256usize],
    pub uuid: cudaUUID_t,
    pub luid: [::std::os::raw::c_char; 8usize],
    pub luidDeviceNodeMask: ::std::os::raw::c_uint,
    pub totalGlobalMem: size_t,
    pub sharedMemPerBlock: size_t,
    pub regsPerBlock: ::std::os::raw::c_int,
    pub warpSize: ::std::os::raw::c_int,
    pub memPitch: size_t,
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    pub clockRate: ::std::os::raw::c_int,
    pub totalConstMem: size_t,
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub textureAlignment: size_t,
    pub texturePitchAlignment: size_t,
    pub deviceOverlap: ::std::os::raw::c_int,
    pub multiProcessorCount: ::std::os::raw::c_int,
    pub kernelExecTimeoutEnabled: ::std::os::raw::c_int,
    pub integrated: ::std::os::raw::c_int,
    pub canMapHostMemory: ::std::os::raw::c_int,
    pub computeMode: ::std::os::raw::c_int,
    pub maxTexture1D: ::std::os::raw::c_int,
    pub maxTexture1DMipmap: ::std::os::raw::c_int,
    pub maxTexture1DLinear: ::std::os::raw::c_int,
    pub maxTexture2D: [::std::os::raw::c_int; 2usize],
    pub maxTexture2DMipmap: [::std::os::raw::c_int; 2usize],
    pub maxTexture2DLinear: [::std::os::raw::c_int; 3usize],
    pub maxTexture2DGather: [::std::os::raw::c_int; 2usize],
    pub maxTexture3D: [::std::os::raw::c_int; 3usize],
    pub maxTexture3DAlt: [::std::os::raw::c_int; 3usize],
    pub maxTextureCubemap: ::std::os::raw::c_int,
    pub maxTexture1DLayered: [::std::os::raw::c_int; 2usize],
    pub maxTexture2DLayered: [::std::os::raw::c_int; 3usize],
    pub maxTextureCubemapLayered: [::std::os::raw::c_int; 2usize],
    pub maxSurface1D: ::std::os::raw::c_int,
    pub maxSurface2D: [::std::os::raw::c_int; 2usize],
    pub maxSurface3D: [::std::os::raw::c_int; 3usize],
    pub maxSurface1DLayered: [::std::os::raw::c_int; 2usize],
    pub maxSurface2DLayered: [::std::os::raw::c_int; 3usize],
    pub maxSurfaceCubemap: ::std::os::raw::c_int,
    pub maxSurfaceCubemapLayered: [::std::os::raw::c_int; 2usize],
    pub surfaceAlignment: size_t,
    pub concurrentKernels: ::std::os::raw::c_int,
    pub ECCEnabled: ::std::os::raw::c_int,
    pub pciBusID: ::std::os::raw::c_int,
    pub pciDeviceID: ::std::os::raw::c_int,
    pub pciDomainID: ::std::os::raw::c_int,
    pub tccDriver: ::std::os::raw::c_int,
    pub asyncEngineCount: ::std::os::raw::c_int,
    pub unifiedAddressing: ::std::os::raw::c_int,
    pub memoryClockRate: ::std::os::raw::c_int,
    pub memoryBusWidth: ::std::os::raw::c_int,
    pub l2CacheSize: ::std::os::raw::c_int,
    pub persistingL2CacheMaxSize: ::std::os::raw::c_int,
    pub maxThreadsPerMultiProcessor: ::std::os::raw::c_int,
    pub streamPrioritiesSupported: ::std::os::raw::c_int,
    pub globalL1CacheSupported: ::std::os::raw::c_int,
    pub localL1CacheSupported: ::std::os::raw::c_int,
    pub sharedMemPerMultiprocessor: size_t,
    pub regsPerMultiprocessor: ::std::os::raw::c_int,
    pub managedMemory: ::std::os::raw::c_int,
    pub isMultiGpuBoard: ::std::os::raw::c_int,
    pub multiGpuBoardGroupID: ::std::os::raw::c_int,
    pub hostNativeAtomicSupported: ::std::os::raw::c_int,
    pub singleToDoublePrecisionPerfRatio: ::std::os::raw::c_int,
    pub pageableMemoryAccess: ::std::os::raw::c_int,
    pub concurrentManagedAccess: ::std::os::raw::c_int,
    pub computePreemptionSupported: ::std::os::raw::c_int,
    pub canUseHostPointerForRegisteredMem: ::std::os::raw::c_int,
    pub cooperativeLaunch: ::std::os::raw::c_int,
    pub cooperativeMultiDeviceLaunch: ::std::os::raw::c_int,
    pub sharedMemPerBlockOptin: size_t,
    pub pageableMemoryAccessUsesHostPageTables: ::std::os::raw::c_int,
    pub directManagedMemAccessFromHost: ::std::os::raw::c_int,
    pub maxBlocksPerMultiProcessor: ::std::os::raw::c_int,
    pub accessPolicyMaxWindowSize: ::std::os::raw::c_int,
    pub reservedSharedMemPerBlock: size_t,
}
#[test]
fn bindgen_test_layout_cudaDeviceProp() {
    assert_eq!(
        ::std::mem::size_of::<cudaDeviceProp>(),
        728usize,
        concat!("Size of: ", stringify!(cudaDeviceProp))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaDeviceProp>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaDeviceProp))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
    fn test_field_luid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).luid) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(luid)
            )
        );
    }
    test_field_luid();
    fn test_field_luidDeviceNodeMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).luidDeviceNodeMask) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(luidDeviceNodeMask)
            )
        );
    }
    test_field_luidDeviceNodeMask();
    fn test_field_totalGlobalMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalGlobalMem) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(totalGlobalMem)
            )
        );
    }
    test_field_totalGlobalMem();
    fn test_field_sharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerBlock)
            )
        );
    }
    test_field_sharedMemPerBlock();
    fn test_field_regsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(regsPerBlock)
            )
        );
    }
    test_field_regsPerBlock();
    fn test_field_warpSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).warpSize) as usize - ptr as usize
            },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(warpSize)
            )
        );
    }
    test_field_warpSize();
    fn test_field_memPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memPitch)
            )
        );
    }
    test_field_memPitch();
    fn test_field_maxThreadsPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsPerBlock)
            )
        );
    }
    test_field_maxThreadsPerBlock();
    fn test_field_maxThreadsDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize
            },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsDim)
            )
        );
    }
    test_field_maxThreadsDim();
    fn test_field_maxGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxGridSize)
            )
        );
    }
    test_field_maxGridSize();
    fn test_field_clockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize
            },
            348usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(clockRate)
            )
        );
    }
    test_field_clockRate();
    fn test_field_totalConstMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalConstMem) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(totalConstMem)
            )
        );
    }
    test_field_totalConstMem();
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_textureAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureAlignment) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(textureAlignment)
            )
        );
    }
    test_field_textureAlignment();
    fn test_field_texturePitchAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).texturePitchAlignment) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(texturePitchAlignment)
            )
        );
    }
    test_field_texturePitchAlignment();
    fn test_field_deviceOverlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceOverlap) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(deviceOverlap)
            )
        );
    }
    test_field_deviceOverlap();
    fn test_field_multiProcessorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiProcessorCount) as usize - ptr as usize
            },
            388usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(multiProcessorCount)
            )
        );
    }
    test_field_multiProcessorCount();
    fn test_field_kernelExecTimeoutEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelExecTimeoutEnabled) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(kernelExecTimeoutEnabled)
            )
        );
    }
    test_field_kernelExecTimeoutEnabled();
    fn test_field_integrated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integrated) as usize - ptr as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(integrated)
            )
        );
    }
    test_field_integrated();
    fn test_field_canMapHostMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canMapHostMemory) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(canMapHostMemory)
            )
        );
    }
    test_field_canMapHostMemory();
    fn test_field_computeMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeMode) as usize - ptr as usize
            },
            404usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(computeMode)
            )
        );
    }
    test_field_computeMode();
    fn test_field_maxTexture1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1D) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1D)
            )
        );
    }
    test_field_maxTexture1D();
    fn test_field_maxTexture1DMipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DMipmap) as usize - ptr as usize
            },
            412usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DMipmap)
            )
        );
    }
    test_field_maxTexture1DMipmap();
    fn test_field_maxTexture1DLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DLinear) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DLinear)
            )
        );
    }
    test_field_maxTexture1DLinear();
    fn test_field_maxTexture2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2D) as usize - ptr as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2D)
            )
        );
    }
    test_field_maxTexture2D();
    fn test_field_maxTexture2DMipmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DMipmap) as usize - ptr as usize
            },
            428usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DMipmap)
            )
        );
    }
    test_field_maxTexture2DMipmap();
    fn test_field_maxTexture2DLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DLinear) as usize - ptr as usize
            },
            436usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DLinear)
            )
        );
    }
    test_field_maxTexture2DLinear();
    fn test_field_maxTexture2DGather() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DGather) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DGather)
            )
        );
    }
    test_field_maxTexture2DGather();
    fn test_field_maxTexture3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture3D) as usize - ptr as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture3D)
            )
        );
    }
    test_field_maxTexture3D();
    fn test_field_maxTexture3DAlt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture3DAlt) as usize - ptr as usize
            },
            468usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture3DAlt)
            )
        );
    }
    test_field_maxTexture3DAlt();
    fn test_field_maxTextureCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTextureCubemap) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTextureCubemap)
            )
        );
    }
    test_field_maxTextureCubemap();
    fn test_field_maxTexture1DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture1DLayered) as usize - ptr as usize
            },
            484usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture1DLayered)
            )
        );
    }
    test_field_maxTexture1DLayered();
    fn test_field_maxTexture2DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexture2DLayered) as usize - ptr as usize
            },
            492usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTexture2DLayered)
            )
        );
    }
    test_field_maxTexture2DLayered();
    fn test_field_maxTextureCubemapLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTextureCubemapLayered) as usize - ptr as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxTextureCubemapLayered)
            )
        );
    }
    test_field_maxTextureCubemapLayered();
    fn test_field_maxSurface1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface1D) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface1D)
            )
        );
    }
    test_field_maxSurface1D();
    fn test_field_maxSurface2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface2D) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface2D)
            )
        );
    }
    test_field_maxSurface2D();
    fn test_field_maxSurface3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface3D) as usize - ptr as usize
            },
            524usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface3D)
            )
        );
    }
    test_field_maxSurface3D();
    fn test_field_maxSurface1DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface1DLayered) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface1DLayered)
            )
        );
    }
    test_field_maxSurface1DLayered();
    fn test_field_maxSurface2DLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurface2DLayered) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurface2DLayered)
            )
        );
    }
    test_field_maxSurface2DLayered();
    fn test_field_maxSurfaceCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurfaceCubemap) as usize - ptr as usize
            },
            556usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurfaceCubemap)
            )
        );
    }
    test_field_maxSurfaceCubemap();
    fn test_field_maxSurfaceCubemapLayered() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSurfaceCubemapLayered) as usize - ptr as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxSurfaceCubemapLayered)
            )
        );
    }
    test_field_maxSurfaceCubemapLayered();
    fn test_field_surfaceAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surfaceAlignment) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(surfaceAlignment)
            )
        );
    }
    test_field_surfaceAlignment();
    fn test_field_concurrentKernels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).concurrentKernels) as usize - ptr as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(concurrentKernels)
            )
        );
    }
    test_field_concurrentKernels();
    fn test_field_ECCEnabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ECCEnabled) as usize - ptr as usize
            },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(ECCEnabled)
            )
        );
    }
    test_field_ECCEnabled();
    fn test_field_pciBusID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciBusID) as usize - ptr as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciBusID)
            )
        );
    }
    test_field_pciBusID();
    fn test_field_pciDeviceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDeviceID) as usize - ptr as usize
            },
            588usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciDeviceID)
            )
        );
    }
    test_field_pciDeviceID();
    fn test_field_pciDomainID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDomainID) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pciDomainID)
            )
        );
    }
    test_field_pciDomainID();
    fn test_field_tccDriver() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tccDriver) as usize - ptr as usize
            },
            596usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(tccDriver)
            )
        );
    }
    test_field_tccDriver();
    fn test_field_asyncEngineCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).asyncEngineCount) as usize - ptr as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(asyncEngineCount)
            )
        );
    }
    test_field_asyncEngineCount();
    fn test_field_unifiedAddressing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unifiedAddressing) as usize - ptr as usize
            },
            604usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(unifiedAddressing)
            )
        );
    }
    test_field_unifiedAddressing();
    fn test_field_memoryClockRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryClockRate) as usize - ptr as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryClockRate)
            )
        );
    }
    test_field_memoryClockRate();
    fn test_field_memoryBusWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryBusWidth) as usize - ptr as usize
            },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(memoryBusWidth)
            )
        );
    }
    test_field_memoryBusWidth();
    fn test_field_l2CacheSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2CacheSize) as usize - ptr as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(l2CacheSize)
            )
        );
    }
    test_field_l2CacheSize();
    fn test_field_persistingL2CacheMaxSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persistingL2CacheMaxSize) as usize - ptr as usize
            },
            620usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(persistingL2CacheMaxSize)
            )
        );
    }
    test_field_persistingL2CacheMaxSize();
    fn test_field_maxThreadsPerMultiProcessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxThreadsPerMultiProcessor) as usize - ptr as usize
            },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxThreadsPerMultiProcessor)
            )
        );
    }
    test_field_maxThreadsPerMultiProcessor();
    fn test_field_streamPrioritiesSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streamPrioritiesSupported) as usize - ptr as usize
            },
            628usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(streamPrioritiesSupported)
            )
        );
    }
    test_field_streamPrioritiesSupported();
    fn test_field_globalL1CacheSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalL1CacheSupported) as usize - ptr as usize
            },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(globalL1CacheSupported)
            )
        );
    }
    test_field_globalL1CacheSupported();
    fn test_field_localL1CacheSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localL1CacheSupported) as usize - ptr as usize
            },
            636usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(localL1CacheSupported)
            )
        );
    }
    test_field_localL1CacheSupported();
    fn test_field_sharedMemPerMultiprocessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerMultiprocessor) as usize - ptr as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerMultiprocessor)
            )
        );
    }
    test_field_sharedMemPerMultiprocessor();
    fn test_field_regsPerMultiprocessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regsPerMultiprocessor) as usize - ptr as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(regsPerMultiprocessor)
            )
        );
    }
    test_field_regsPerMultiprocessor();
    fn test_field_managedMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).managedMemory) as usize - ptr as usize
            },
            652usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(managedMemory)
            )
        );
    }
    test_field_managedMemory();
    fn test_field_isMultiGpuBoard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isMultiGpuBoard) as usize - ptr as usize
            },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(isMultiGpuBoard)
            )
        );
    }
    test_field_isMultiGpuBoard();
    fn test_field_multiGpuBoardGroupID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiGpuBoardGroupID) as usize - ptr as usize
            },
            660usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(multiGpuBoardGroupID)
            )
        );
    }
    test_field_multiGpuBoardGroupID();
    fn test_field_hostNativeAtomicSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostNativeAtomicSupported) as usize - ptr as usize
            },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(hostNativeAtomicSupported)
            )
        );
    }
    test_field_hostNativeAtomicSupported();
    fn test_field_singleToDoublePrecisionPerfRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singleToDoublePrecisionPerfRatio) as usize
                    - ptr as usize
            },
            668usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(singleToDoublePrecisionPerfRatio)
            )
        );
    }
    test_field_singleToDoublePrecisionPerfRatio();
    fn test_field_pageableMemoryAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableMemoryAccess) as usize - ptr as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pageableMemoryAccess)
            )
        );
    }
    test_field_pageableMemoryAccess();
    fn test_field_concurrentManagedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).concurrentManagedAccess) as usize - ptr as usize
            },
            676usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(concurrentManagedAccess)
            )
        );
    }
    test_field_concurrentManagedAccess();
    fn test_field_computePreemptionSupported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computePreemptionSupported) as usize - ptr as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(computePreemptionSupported)
            )
        );
    }
    test_field_computePreemptionSupported();
    fn test_field_canUseHostPointerForRegisteredMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canUseHostPointerForRegisteredMem) as usize
                    - ptr as usize
            },
            684usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(canUseHostPointerForRegisteredMem)
            )
        );
    }
    test_field_canUseHostPointerForRegisteredMem();
    fn test_field_cooperativeLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeLaunch) as usize - ptr as usize
            },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(cooperativeLaunch)
            )
        );
    }
    test_field_cooperativeLaunch();
    fn test_field_cooperativeMultiDeviceLaunch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceLaunch) as usize - ptr as usize
            },
            692usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(cooperativeMultiDeviceLaunch)
            )
        );
    }
    test_field_cooperativeMultiDeviceLaunch();
    fn test_field_sharedMemPerBlockOptin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemPerBlockOptin) as usize - ptr as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(sharedMemPerBlockOptin)
            )
        );
    }
    test_field_sharedMemPerBlockOptin();
    fn test_field_pageableMemoryAccessUsesHostPageTables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableMemoryAccessUsesHostPageTables) as usize
                    - ptr as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(pageableMemoryAccessUsesHostPageTables)
            )
        );
    }
    test_field_pageableMemoryAccessUsesHostPageTables();
    fn test_field_directManagedMemAccessFromHost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directManagedMemAccessFromHost) as usize - ptr as usize
            },
            708usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(directManagedMemAccessFromHost)
            )
        );
    }
    test_field_directManagedMemAccessFromHost();
    fn test_field_maxBlocksPerMultiProcessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBlocksPerMultiProcessor) as usize - ptr as usize
            },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(maxBlocksPerMultiProcessor)
            )
        );
    }
    test_field_maxBlocksPerMultiProcessor();
    fn test_field_accessPolicyMaxWindowSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyMaxWindowSize) as usize - ptr as usize
            },
            716usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(accessPolicyMaxWindowSize)
            )
        );
    }
    test_field_accessPolicyMaxWindowSize();
    fn test_field_reservedSharedMemPerBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaDeviceProp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reservedSharedMemPerBlock) as usize - ptr as usize
            },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaDeviceProp),
                "::",
                stringify!(reservedSharedMemPerBlock)
            )
        );
    }
    test_field_reservedSharedMemPerBlock();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcEventHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaIpcEventHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaIpcEventHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudaIpcEventHandle_t = cudaIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaIpcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_cudaIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<cudaIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(cudaIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(cudaIpcMemHandle_st))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaIpcMemHandle_st>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaIpcMemHandle_st),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type cudaIpcMemHandle_t = cudaIpcMemHandle_st;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueFd:
    cudaExternalMemoryHandleType = 1;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32:
    cudaExternalMemoryHandleType = 2;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32Kmt:
    cudaExternalMemoryHandleType = 3;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Heap:
    cudaExternalMemoryHandleType = 4;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Resource:
    cudaExternalMemoryHandleType = 5;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11Resource:
    cudaExternalMemoryHandleType = 6;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11ResourceKmt:
    cudaExternalMemoryHandleType = 7;
pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeNvSciBuf:
    cudaExternalMemoryHandleType = 8;
pub type cudaExternalMemoryHandleType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc {
    pub type_: cudaExternalMemoryHandleType,
    pub handle: cudaExternalMemoryHandleDesc__bindgen_ty_1,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciBufObject() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc__bindgen_ty_1),
                "::",
                stringify!(nvSciBufObject)
            )
        );
    }
    test_field_nvSciBufObject();
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryHandleDesc>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryHandleDesc))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryHandleDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryBufferDesc {
    pub offset: ::std::os::raw::c_ulonglong,
    pub size: ::std::os::raw::c_ulonglong,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryBufferDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryBufferDesc>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalMemoryBufferDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryBufferDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalMemoryBufferDesc))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalMemoryBufferDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryBufferDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalMemoryMipmappedArrayDesc {
    pub offset: ::std::os::raw::c_ulonglong,
    pub formatDesc: cudaChannelFormatDesc,
    pub extent: cudaExtent,
    pub flags: ::std::os::raw::c_uint,
    pub numLevels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalMemoryMipmappedArrayDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalMemoryMipmappedArrayDesc>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalMemoryMipmappedArrayDesc)
        )
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_formatDesc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatDesc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(formatDesc)
            )
        );
    }
    test_field_formatDesc();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_numLevels() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalMemoryMipmappedArrayDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalMemoryMipmappedArrayDesc),
                "::",
                stringify!(numLevels)
            )
        );
    }
    test_field_numLevels();
}
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueFd:
    cudaExternalSemaphoreHandleType = 1;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32:
    cudaExternalSemaphoreHandleType = 2;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt:
    cudaExternalSemaphoreHandleType = 3;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D12Fence:
    cudaExternalSemaphoreHandleType = 4;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D11Fence:
    cudaExternalSemaphoreHandleType = 5;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeNvSciSync:
    cudaExternalSemaphoreHandleType = 6;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutex:
    cudaExternalSemaphoreHandleType = 7;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutexKmt:
    cudaExternalSemaphoreHandleType = 8;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd:
    cudaExternalSemaphoreHandleType = 9;
pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32:
    cudaExternalSemaphoreHandleType = 10;
pub type cudaExternalSemaphoreHandleType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc {
    pub type_: cudaExternalSemaphoreHandleType,
    pub handle: cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub win32: cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1)
        )
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_win32() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(win32)
            )
        );
    }
    test_field_win32();
    fn test_field_nvSciSyncObj() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreHandleDesc__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc__bindgen_ty_1),
                "::",
                stringify!(nvSciSyncObj)
            )
        );
    }
    test_field_nvSciSyncObj();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreHandleDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreHandleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreHandleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreHandleDesc))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(handle)
            )
        );
    }
    test_field_handle();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreHandleDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreHandleDesc),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1 {
    pub params: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams_v1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams_v1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams_v1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams_v1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams_v1)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams_v1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1 {
    pub params: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams_v1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams_v1>(),
        40usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams_v1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams_v1)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams_v1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams {
    pub params: cudaExternalSemaphoreSignalParams__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreSignalParams__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreSignalParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalParams)
        )
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams {
    pub params: cudaExternalSemaphoreWaitParams__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
    pub fence: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::std::os::raw::c_ulonglong,
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_timeoutMs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(timeoutMs)
            )
        );
    }
    test_field_timeoutMs();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1)
        )
    );
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_nvSciSync() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(nvSciSync)
            )
        );
    }
    test_field_nvSciSync();
    fn test_field_keyedMutex() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(keyedMutex)
            )
        );
    }
    test_field_keyedMutex();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < cudaExternalSemaphoreWaitParams__bindgen_ty_1 > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitParams>(),
        144usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaExternalSemaphoreWaitParams))
    );
    fn test_field_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(params)
            )
        );
    }
    test_field_params();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitParams),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub use self::cudaError as cudaError_t;
pub type cudaStream_t = *mut CUstream_st;
pub type cudaEvent_t = *mut CUevent_st;
pub type cudaGraphicsResource_t = *mut cudaGraphicsResource;
pub use self::cudaOutputMode as cudaOutputMode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalMemory_st {
    _unused: [u8; 0],
}
pub type cudaExternalMemory_t = *mut CUexternalMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexternalSemaphore_st {
    _unused: [u8; 0],
}
pub type cudaExternalSemaphore_t = *mut CUexternalSemaphore_st;
pub type cudaGraph_t = *mut CUgraph_st;
pub type cudaGraphNode_t = *mut CUgraphNode_st;
pub type cudaUserObject_t = *mut CUuserObject_st;
pub type cudaFunction_t = *mut CUfunc_st;
pub type cudaMemPool_t = *mut CUmemPoolHandle_st;
pub const cudaCGScope_cudaCGScopeInvalid: cudaCGScope = 0;
pub const cudaCGScope_cudaCGScopeGrid: cudaCGScope = 1;
pub const cudaCGScope_cudaCGScopeMultiGrid: cudaCGScope = 2;
pub type cudaCGScope = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaLaunchParams {
    pub func: *mut ::std::os::raw::c_void,
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub args: *mut *mut ::std::os::raw::c_void,
    pub sharedMem: size_t,
    pub stream: cudaStream_t,
}
#[test]
fn bindgen_test_layout_cudaLaunchParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaLaunchParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaLaunchParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaLaunchParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaLaunchParams))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_args() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(args)
            )
        );
    }
    test_field_args();
    fn test_field_sharedMem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMem) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(sharedMem)
            )
        );
    }
    test_field_sharedMem();
    fn test_field_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaLaunchParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaLaunchParams),
                "::",
                stringify!(stream)
            )
        );
    }
    test_field_stream();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaKernelNodeParams {
    pub func: *mut ::std::os::raw::c_void,
    pub gridDim: dim3,
    pub blockDim: dim3,
    pub sharedMemBytes: ::std::os::raw::c_uint,
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeParams>(),
        56usize,
        concat!("Size of: ", stringify!(cudaKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeParams))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_gridDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(gridDim)
            )
        );
    }
    test_field_gridDim();
    fn test_field_blockDim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(blockDim)
            )
        );
    }
    test_field_blockDim();
    fn test_field_sharedMemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(sharedMemBytes)
            )
        );
    }
    test_field_sharedMemBytes();
    fn test_field_kernelParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(kernelParams)
            )
        );
    }
    test_field_kernelParams();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeParams),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreSignalNodeParams {
    pub extSemArray: *mut cudaExternalSemaphore_t,
    pub paramsArray: *const cudaExternalSemaphoreSignalParams,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreSignalNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreSignalNodeParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreSignalNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreSignalNodeParams)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreSignalNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreSignalNodeParams),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaExternalSemaphoreWaitNodeParams {
    pub extSemArray: *mut cudaExternalSemaphore_t,
    pub paramsArray: *const cudaExternalSemaphoreWaitParams,
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cudaExternalSemaphoreWaitNodeParams() {
    assert_eq!(
        ::std::mem::size_of::<cudaExternalSemaphoreWaitNodeParams>(),
        24usize,
        concat!("Size of: ", stringify!(cudaExternalSemaphoreWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaExternalSemaphoreWaitNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cudaExternalSemaphoreWaitNodeParams)
        )
    );
    fn test_field_extSemArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(extSemArray)
            )
        );
    }
    test_field_extSemArray();
    fn test_field_paramsArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(paramsArray)
            )
        );
    }
    test_field_paramsArray();
    fn test_field_numExtSems() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<cudaExternalSemaphoreWaitNodeParams>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaExternalSemaphoreWaitNodeParams),
                "::",
                stringify!(numExtSems)
            )
        );
    }
    test_field_numExtSems();
}
pub const cudaGraphNodeType_cudaGraphNodeTypeKernel: cudaGraphNodeType = 0;
pub const cudaGraphNodeType_cudaGraphNodeTypeMemcpy: cudaGraphNodeType = 1;
pub const cudaGraphNodeType_cudaGraphNodeTypeMemset: cudaGraphNodeType = 2;
pub const cudaGraphNodeType_cudaGraphNodeTypeHost: cudaGraphNodeType = 3;
pub const cudaGraphNodeType_cudaGraphNodeTypeGraph: cudaGraphNodeType = 4;
pub const cudaGraphNodeType_cudaGraphNodeTypeEmpty: cudaGraphNodeType = 5;
pub const cudaGraphNodeType_cudaGraphNodeTypeWaitEvent: cudaGraphNodeType = 6;
pub const cudaGraphNodeType_cudaGraphNodeTypeEventRecord: cudaGraphNodeType = 7;
pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreSignal: cudaGraphNodeType = 8;
pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreWait: cudaGraphNodeType = 9;
pub const cudaGraphNodeType_cudaGraphNodeTypeMemAlloc: cudaGraphNodeType = 10;
pub const cudaGraphNodeType_cudaGraphNodeTypeMemFree: cudaGraphNodeType = 11;
pub const cudaGraphNodeType_cudaGraphNodeTypeCount: cudaGraphNodeType = 12;
pub type cudaGraphNodeType = ::std::os::raw::c_uint;
pub type cudaGraphExec_t = *mut CUgraphExec_st;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateSuccess: cudaGraphExecUpdateResult = 0;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateError: cudaGraphExecUpdateResult = 1;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorTopologyChanged:
    cudaGraphExecUpdateResult = 2;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNodeTypeChanged:
    cudaGraphExecUpdateResult = 3;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorFunctionChanged:
    cudaGraphExecUpdateResult = 4;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorParametersChanged:
    cudaGraphExecUpdateResult = 5;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNotSupported:
    cudaGraphExecUpdateResult = 6;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorUnsupportedFunctionChange:
    cudaGraphExecUpdateResult = 7;
pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorAttributesChanged:
    cudaGraphExecUpdateResult = 8;
pub type cudaGraphExecUpdateResult = ::std::os::raw::c_uint;
pub const cudaGetDriverEntryPointFlags_cudaEnableDefault: cudaGetDriverEntryPointFlags = 0;
pub const cudaGetDriverEntryPointFlags_cudaEnableLegacyStream: cudaGetDriverEntryPointFlags = 1;
pub const cudaGetDriverEntryPointFlags_cudaEnablePerThreadDefaultStream:
    cudaGetDriverEntryPointFlags = 2;
pub type cudaGetDriverEntryPointFlags = ::std::os::raw::c_uint;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsVerbose: cudaGraphDebugDotFlags = 1;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsKernelNodeParams: cudaGraphDebugDotFlags = 4;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsMemcpyNodeParams: cudaGraphDebugDotFlags = 8;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsMemsetNodeParams: cudaGraphDebugDotFlags =
    16;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsHostNodeParams: cudaGraphDebugDotFlags = 32;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsEventNodeParams: cudaGraphDebugDotFlags = 64;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsExtSemasSignalNodeParams:
    cudaGraphDebugDotFlags = 128;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsExtSemasWaitNodeParams:
    cudaGraphDebugDotFlags = 256;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsKernelNodeAttributes:
    cudaGraphDebugDotFlags = 512;
pub const cudaGraphDebugDotFlags_cudaGraphDebugDotFlagsHandles: cudaGraphDebugDotFlags = 1024;
pub type cudaGraphDebugDotFlags = ::std::os::raw::c_uint;
pub const cudaGraphInstantiateFlags_cudaGraphInstantiateFlagAutoFreeOnLaunch:
    cudaGraphInstantiateFlags = 1;
pub const cudaGraphInstantiateFlags_cudaGraphInstantiateFlagUseNodePriority:
    cudaGraphInstantiateFlags = 8;
pub type cudaGraphInstantiateFlags = ::std::os::raw::c_uint;
pub const cudaStreamAttrID_cudaStreamAttributeAccessPolicyWindow: cudaStreamAttrID = 1;
pub const cudaStreamAttrID_cudaStreamAttributeSynchronizationPolicy: cudaStreamAttrID = 3;
pub type cudaStreamAttrID = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaStreamAttrValue {
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub syncPolicy: cudaSynchronizationPolicy,
}
#[test]
fn bindgen_test_layout_cudaStreamAttrValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaStreamAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaStreamAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaStreamAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaStreamAttrValue))
    );
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaStreamAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaStreamAttrValue),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_syncPolicy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaStreamAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaStreamAttrValue),
                "::",
                stringify!(syncPolicy)
            )
        );
    }
    test_field_syncPolicy();
}
pub const cudaKernelNodeAttrID_cudaKernelNodeAttributeAccessPolicyWindow: cudaKernelNodeAttrID = 1;
pub const cudaKernelNodeAttrID_cudaKernelNodeAttributeCooperative: cudaKernelNodeAttrID = 2;
pub const cudaKernelNodeAttrID_cudaKernelNodeAttributePriority: cudaKernelNodeAttrID = 8;
pub type cudaKernelNodeAttrID = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cudaKernelNodeAttrValue {
    pub accessPolicyWindow: cudaAccessPolicyWindow,
    pub cooperative: ::std::os::raw::c_int,
    pub priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaKernelNodeAttrValue() {
    assert_eq!(
        ::std::mem::size_of::<cudaKernelNodeAttrValue>(),
        32usize,
        concat!("Size of: ", stringify!(cudaKernelNodeAttrValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaKernelNodeAttrValue>(),
        8usize,
        concat!("Alignment of ", stringify!(cudaKernelNodeAttrValue))
    );
    fn test_field_accessPolicyWindow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeAttrValue),
                "::",
                stringify!(accessPolicyWindow)
            )
        );
    }
    test_field_accessPolicyWindow();
    fn test_field_cooperative() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeAttrValue),
                "::",
                stringify!(cooperative)
            )
        );
    }
    test_field_cooperative();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaKernelNodeAttrValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaKernelNodeAttrValue),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
}
pub const cudaSurfaceBoundaryMode_cudaBoundaryModeZero: cudaSurfaceBoundaryMode = 0;
pub const cudaSurfaceBoundaryMode_cudaBoundaryModeClamp: cudaSurfaceBoundaryMode = 1;
pub const cudaSurfaceBoundaryMode_cudaBoundaryModeTrap: cudaSurfaceBoundaryMode = 2;
pub type cudaSurfaceBoundaryMode = ::std::os::raw::c_uint;
pub const cudaSurfaceFormatMode_cudaFormatModeForced: cudaSurfaceFormatMode = 0;
pub const cudaSurfaceFormatMode_cudaFormatModeAuto: cudaSurfaceFormatMode = 1;
pub type cudaSurfaceFormatMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surfaceReference {
    pub channelDesc: cudaChannelFormatDesc,
}
#[test]
fn bindgen_test_layout_surfaceReference() {
    assert_eq!(
        ::std::mem::size_of::<surfaceReference>(),
        20usize,
        concat!("Size of: ", stringify!(surfaceReference))
    );
    assert_eq!(
        ::std::mem::align_of::<surfaceReference>(),
        4usize,
        concat!("Alignment of ", stringify!(surfaceReference))
    );
    fn test_field_channelDesc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<surfaceReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channelDesc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(surfaceReference),
                "::",
                stringify!(channelDesc)
            )
        );
    }
    test_field_channelDesc();
}
pub type cudaSurfaceObject_t = ::std::os::raw::c_ulonglong;
pub const cudaTextureAddressMode_cudaAddressModeWrap: cudaTextureAddressMode = 0;
pub const cudaTextureAddressMode_cudaAddressModeClamp: cudaTextureAddressMode = 1;
pub const cudaTextureAddressMode_cudaAddressModeMirror: cudaTextureAddressMode = 2;
pub const cudaTextureAddressMode_cudaAddressModeBorder: cudaTextureAddressMode = 3;
pub type cudaTextureAddressMode = ::std::os::raw::c_uint;
pub const cudaTextureFilterMode_cudaFilterModePoint: cudaTextureFilterMode = 0;
pub const cudaTextureFilterMode_cudaFilterModeLinear: cudaTextureFilterMode = 1;
pub type cudaTextureFilterMode = ::std::os::raw::c_uint;
pub const cudaTextureReadMode_cudaReadModeElementType: cudaTextureReadMode = 0;
pub const cudaTextureReadMode_cudaReadModeNormalizedFloat: cudaTextureReadMode = 1;
pub type cudaTextureReadMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::std::os::raw::c_int,
    pub filterMode: cudaTextureFilterMode,
    pub addressMode: [cudaTextureAddressMode; 3usize],
    pub channelDesc: cudaChannelFormatDesc,
    pub sRGB: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: cudaTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub disableTrilinearOptimization: ::std::os::raw::c_int,
    pub __cudaReserved: [::std::os::raw::c_int; 14usize],
}
#[test]
fn bindgen_test_layout_textureReference() {
    assert_eq!(
        ::std::mem::size_of::<textureReference>(),
        124usize,
        concat!("Size of: ", stringify!(textureReference))
    );
    assert_eq!(
        ::std::mem::align_of::<textureReference>(),
        4usize,
        concat!("Alignment of ", stringify!(textureReference))
    );
    fn test_field_normalized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).normalized) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(normalized)
            )
        );
    }
    test_field_normalized();
    fn test_field_filterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(filterMode)
            )
        );
    }
    test_field_filterMode();
    fn test_field_addressMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(addressMode)
            )
        );
    }
    test_field_addressMode();
    fn test_field_channelDesc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channelDesc) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(channelDesc)
            )
        );
    }
    test_field_channelDesc();
    fn test_field_sRGB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sRGB) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(sRGB)
            )
        );
    }
    test_field_sRGB();
    fn test_field_maxAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(maxAnisotropy)
            )
        );
    }
    test_field_maxAnisotropy();
    fn test_field_mipmapFilterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(mipmapFilterMode)
            )
        );
    }
    test_field_mipmapFilterMode();
    fn test_field_mipmapLevelBias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(mipmapLevelBias)
            )
        );
    }
    test_field_mipmapLevelBias();
    fn test_field_minMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(minMipmapLevelClamp)
            )
        );
    }
    test_field_minMipmapLevelClamp();
    fn test_field_maxMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(maxMipmapLevelClamp)
            )
        );
    }
    test_field_maxMipmapLevelClamp();
    fn test_field_disableTrilinearOptimization() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disableTrilinearOptimization) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(disableTrilinearOptimization)
            )
        );
    }
    test_field_disableTrilinearOptimization();
    fn test_field___cudaReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<textureReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cudaReserved) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(textureReference),
                "::",
                stringify!(__cudaReserved)
            )
        );
    }
    test_field___cudaReserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cudaTextureDesc {
    pub addressMode: [cudaTextureAddressMode; 3usize],
    pub filterMode: cudaTextureFilterMode,
    pub readMode: cudaTextureReadMode,
    pub sRGB: ::std::os::raw::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::std::os::raw::c_int,
    pub maxAnisotropy: ::std::os::raw::c_uint,
    pub mipmapFilterMode: cudaTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub disableTrilinearOptimization: ::std::os::raw::c_int,
    pub seamlessCubemap: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cudaTextureDesc() {
    assert_eq!(
        ::std::mem::size_of::<cudaTextureDesc>(),
        72usize,
        concat!("Size of: ", stringify!(cudaTextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<cudaTextureDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(cudaTextureDesc))
    );
    fn test_field_addressMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(addressMode)
            )
        );
    }
    test_field_addressMode();
    fn test_field_filterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(filterMode)
            )
        );
    }
    test_field_filterMode();
    fn test_field_readMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(readMode)
            )
        );
    }
    test_field_readMode();
    fn test_field_sRGB() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sRGB) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(sRGB)
            )
        );
    }
    test_field_sRGB();
    fn test_field_borderColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(borderColor)
            )
        );
    }
    test_field_borderColor();
    fn test_field_normalizedCoords() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).normalizedCoords) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(normalizedCoords)
            )
        );
    }
    test_field_normalizedCoords();
    fn test_field_maxAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(maxAnisotropy)
            )
        );
    }
    test_field_maxAnisotropy();
    fn test_field_mipmapFilterMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(mipmapFilterMode)
            )
        );
    }
    test_field_mipmapFilterMode();
    fn test_field_mipmapLevelBias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(mipmapLevelBias)
            )
        );
    }
    test_field_mipmapLevelBias();
    fn test_field_minMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(minMipmapLevelClamp)
            )
        );
    }
    test_field_minMipmapLevelClamp();
    fn test_field_maxMipmapLevelClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(maxMipmapLevelClamp)
            )
        );
    }
    test_field_maxMipmapLevelClamp();
    fn test_field_disableTrilinearOptimization() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disableTrilinearOptimization) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(disableTrilinearOptimization)
            )
        );
    }
    test_field_disableTrilinearOptimization();
    fn test_field_seamlessCubemap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cudaTextureDesc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seamlessCubemap) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(cudaTextureDesc),
                "::",
                stringify!(seamlessCubemap)
            )
        );
    }
    test_field_seamlessCubemap();
}
pub type cudaTextureObject_t = ::std::os::raw::c_ulonglong;
pub const cudaDataType_t_CUDA_R_16F: cudaDataType_t = 2;
pub const cudaDataType_t_CUDA_C_16F: cudaDataType_t = 6;
pub const cudaDataType_t_CUDA_R_16BF: cudaDataType_t = 14;
pub const cudaDataType_t_CUDA_C_16BF: cudaDataType_t = 15;
pub const cudaDataType_t_CUDA_R_32F: cudaDataType_t = 0;
pub const cudaDataType_t_CUDA_C_32F: cudaDataType_t = 4;
pub const cudaDataType_t_CUDA_R_64F: cudaDataType_t = 1;
pub const cudaDataType_t_CUDA_C_64F: cudaDataType_t = 5;
pub const cudaDataType_t_CUDA_R_4I: cudaDataType_t = 16;
pub const cudaDataType_t_CUDA_C_4I: cudaDataType_t = 17;
pub const cudaDataType_t_CUDA_R_4U: cudaDataType_t = 18;
pub const cudaDataType_t_CUDA_C_4U: cudaDataType_t = 19;
pub const cudaDataType_t_CUDA_R_8I: cudaDataType_t = 3;
pub const cudaDataType_t_CUDA_C_8I: cudaDataType_t = 7;
pub const cudaDataType_t_CUDA_R_8U: cudaDataType_t = 8;
pub const cudaDataType_t_CUDA_C_8U: cudaDataType_t = 9;
pub const cudaDataType_t_CUDA_R_16I: cudaDataType_t = 20;
pub const cudaDataType_t_CUDA_C_16I: cudaDataType_t = 21;
pub const cudaDataType_t_CUDA_R_16U: cudaDataType_t = 22;
pub const cudaDataType_t_CUDA_C_16U: cudaDataType_t = 23;
pub const cudaDataType_t_CUDA_R_32I: cudaDataType_t = 10;
pub const cudaDataType_t_CUDA_C_32I: cudaDataType_t = 11;
pub const cudaDataType_t_CUDA_R_32U: cudaDataType_t = 12;
pub const cudaDataType_t_CUDA_C_32U: cudaDataType_t = 13;
pub const cudaDataType_t_CUDA_R_64I: cudaDataType_t = 24;
pub const cudaDataType_t_CUDA_C_64I: cudaDataType_t = 25;
pub const cudaDataType_t_CUDA_R_64U: cudaDataType_t = 26;
pub const cudaDataType_t_CUDA_C_64U: cudaDataType_t = 27;
pub type cudaDataType_t = ::std::os::raw::c_uint;
pub use self::cudaDataType_t as cudaDataType;
pub const libraryPropertyType_t_MAJOR_VERSION: libraryPropertyType_t = 0;
pub const libraryPropertyType_t_MINOR_VERSION: libraryPropertyType_t = 1;
pub const libraryPropertyType_t_PATCH_LEVEL: libraryPropertyType_t = 2;
pub type libraryPropertyType_t = ::std::os::raw::c_uint;
pub use self::libraryPropertyType_t as libraryPropertyType;
extern "C" {
    pub fn cudaDeviceReset() -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSynchronize() -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetLimit(limit: cudaLimit, value: size_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetLimit(pValue: *mut size_t, limit: cudaLimit) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut size_t,
        fmtDesc: *const cudaChannelFormatDesc,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetCacheConfig(pCacheConfig: *mut cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetCacheConfig(cacheConfig: cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetSharedMemConfig(pConfig: *mut cudaSharedMemConfig) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetSharedMemConfig(config: cudaSharedMemConfig) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetByPCIBusId(
        device: *mut ::std::os::raw::c_int,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcGetEventHandle(
        handle: *mut cudaIpcEventHandle_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcOpenEventHandle(
        event: *mut cudaEvent_t,
        handle: cudaIpcEventHandle_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcGetMemHandle(
        handle: *mut cudaIpcMemHandle_t,
        devPtr: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcOpenMemHandle(
        devPtr: *mut *mut ::std::os::raw::c_void,
        handle: cudaIpcMemHandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaIpcCloseMemHandle(devPtr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceFlushGPUDirectRDMAWrites(
        target: cudaFlushGPUDirectRDMAWritesTarget,
        scope: cudaFlushGPUDirectRDMAWritesScope,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadExit() -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadSynchronize() -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadSetLimit(limit: cudaLimit, value: size_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadGetLimit(pValue: *mut size_t, limit: cudaLimit) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadGetCacheConfig(pCacheConfig: *mut cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadSetCacheConfig(cacheConfig: cudaFuncCache) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetLastError() -> cudaError_t;
}
extern "C" {
    pub fn cudaPeekAtLastError() -> cudaError_t;
}
extern "C" {
    pub fn cudaGetErrorName(error: cudaError_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cudaGetErrorString(error: cudaError_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cudaGetDeviceCount(count: *mut ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDeviceProperties(
        prop: *mut cudaDeviceProp,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: cudaDeviceAttr,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetDefaultMemPool(
        memPool: *mut cudaMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetMemPool(
        device: ::std::os::raw::c_int,
        memPool: cudaMemPool_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetMemPool(
        memPool: *mut cudaMemPool_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::os::raw::c_void,
        device: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attr: cudaDeviceP2PAttr,
        srcDevice: ::std::os::raw::c_int,
        dstDevice: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaChooseDevice(
        device: *mut ::std::os::raw::c_int,
        prop: *const cudaDeviceProp,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDevice(device: ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDevice(device: *mut ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetValidDevices(
        device_arr: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDeviceFlags(flags: ::std::os::raw::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDeviceFlags(flags: *mut ::std::os::raw::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCreate(pStream: *mut cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCreateWithFlags(
        pStream: *mut cudaStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCreateWithPriority(
        pStream: *mut cudaStream_t,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetPriority(
        hStream: cudaStream_t,
        priority: *mut ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetFlags(
        hStream: cudaStream_t,
        flags: *mut ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaCtxResetPersistingL2Cache() -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamCopyAttributes(dst: cudaStream_t, src: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetAttribute(
        hStream: cudaStream_t,
        attr: cudaStreamAttrID,
        value_out: *mut cudaStreamAttrValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamSetAttribute(
        hStream: cudaStream_t,
        attr: cudaStreamAttrID,
        value: *const cudaStreamAttrValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamDestroy(stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamWaitEvent(
        stream: cudaStream_t,
        event: cudaEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
pub type cudaStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: cudaStream_t,
        status: cudaError_t,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn cudaStreamAddCallback(
        stream: cudaStream_t,
        callback: cudaStreamCallback_t,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamSynchronize(stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamQuery(stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamAttachMemAsync(
        stream: cudaStream_t,
        devPtr: *mut ::std::os::raw::c_void,
        length: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamBeginCapture(stream: cudaStream_t, mode: cudaStreamCaptureMode)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaThreadExchangeStreamCaptureMode(mode: *mut cudaStreamCaptureMode) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamEndCapture(stream: cudaStream_t, pGraph: *mut cudaGraph_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamIsCapturing(
        stream: cudaStream_t,
        pCaptureStatus: *mut cudaStreamCaptureStatus,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetCaptureInfo(
        stream: cudaStream_t,
        pCaptureStatus: *mut cudaStreamCaptureStatus,
        pId: *mut ::std::os::raw::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamGetCaptureInfo_v2(
        stream: cudaStream_t,
        captureStatus_out: *mut cudaStreamCaptureStatus,
        id_out: *mut ::std::os::raw::c_ulonglong,
        graph_out: *mut cudaGraph_t,
        dependencies_out: *mut *const cudaGraphNode_t,
        numDependencies_out: *mut size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaStreamUpdateCaptureDependencies(
        stream: cudaStream_t,
        dependencies: *mut cudaGraphNode_t,
        numDependencies: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventCreate(event: *mut cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventCreateWithFlags(
        event: *mut cudaEvent_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventRecord(event: cudaEvent_t, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventRecordWithFlags(
        event: cudaEvent_t,
        stream: cudaStream_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventQuery(event: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventSynchronize(event: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventDestroy(event: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaEventElapsedTime(ms: *mut f32, start: cudaEvent_t, end: cudaEvent_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaImportExternalMemory(
        extMem_out: *mut cudaExternalMemory_t,
        memHandleDesc: *const cudaExternalMemoryHandleDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        extMem: cudaExternalMemory_t,
        bufferDesc: *const cudaExternalMemoryBufferDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut cudaMipmappedArray_t,
        extMem: cudaExternalMemory_t,
        mipmapDesc: *const cudaExternalMemoryMipmappedArrayDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroyExternalMemory(extMem: cudaExternalMemory_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaImportExternalSemaphore(
        extSem_out: *mut cudaExternalSemaphore_t,
        semHandleDesc: *const cudaExternalSemaphoreHandleDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSignalExternalSemaphoresAsync_v2(
        extSemArray: *const cudaExternalSemaphore_t,
        paramsArray: *const cudaExternalSemaphoreSignalParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaWaitExternalSemaphoresAsync_v2(
        extSemArray: *const cudaExternalSemaphore_t,
        paramsArray: *const cudaExternalSemaphoreWaitParams,
        numExtSems: ::std::os::raw::c_uint,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroyExternalSemaphore(extSem: cudaExternalSemaphore_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchKernel(
        func: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMem: size_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchCooperativeKernel(
        func: *const ::std::os::raw::c_void,
        gridDim: dim3,
        blockDim: dim3,
        args: *mut *mut ::std::os::raw::c_void,
        sharedMem: size_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut cudaLaunchParams,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncSetCacheConfig(
        func: *const ::std::os::raw::c_void,
        cacheConfig: cudaFuncCache,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncSetSharedMemConfig(
        func: *const ::std::os::raw::c_void,
        config: cudaSharedMemConfig,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncGetAttributes(
        attr: *mut cudaFuncAttributes,
        func: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFuncSetAttribute(
        func: *const ::std::os::raw::c_void,
        attr: cudaFuncAttribute,
        value: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDoubleForDevice(d: *mut f64) -> cudaError_t;
}
extern "C" {
    pub fn cudaSetDoubleForHost(d: *mut f64) -> cudaError_t;
}
extern "C" {
    pub fn cudaLaunchHostFunc(
        stream: cudaStream_t,
        fn_: cudaHostFn_t,
        userData: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut size_t,
        func: *const ::std::os::raw::c_void,
        numBlocks: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_void,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocManaged(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMalloc(devPtr: *mut *mut ::std::os::raw::c_void, size: size_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocHost(ptr: *mut *mut ::std::os::raw::c_void, size: size_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocPitch(
        devPtr: *mut *mut ::std::os::raw::c_void,
        pitch: *mut size_t,
        width: size_t,
        height: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocArray(
        array: *mut cudaArray_t,
        desc: *const cudaChannelFormatDesc,
        width: size_t,
        height: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFree(devPtr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeHost(ptr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeArray(array: cudaArray_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeMipmappedArray(mipmappedArray: cudaMipmappedArray_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostAlloc(
        pHost: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostRegister(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostUnregister(ptr: *mut ::std::os::raw::c_void) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostGetDevicePointer(
        pDevice: *mut *mut ::std::os::raw::c_void,
        pHost: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaHostGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        pHost: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMalloc3D(pitchedDevPtr: *mut cudaPitchedPtr, extent: cudaExtent) -> cudaError_t;
}
extern "C" {
    pub fn cudaMalloc3DArray(
        array: *mut cudaArray_t,
        desc: *const cudaChannelFormatDesc,
        extent: cudaExtent,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocMipmappedArray(
        mipmappedArray: *mut cudaMipmappedArray_t,
        desc: *const cudaChannelFormatDesc,
        extent: cudaExtent,
        numLevels: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetMipmappedArrayLevel(
        levelArray: *mut cudaArray_t,
        mipmappedArray: cudaMipmappedArray_const_t,
        level: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3D(p: *const cudaMemcpy3DParms) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3DPeer(p: *const cudaMemcpy3DPeerParms) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3DAsync(p: *const cudaMemcpy3DParms, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy3DPeerAsync(
        p: *const cudaMemcpy3DPeerParms,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemGetInfo(free: *mut size_t, total: *mut size_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetInfo(
        desc: *mut cudaChannelFormatDesc,
        extent: *mut cudaExtent,
        flags: *mut ::std::os::raw::c_uint,
        array: cudaArray_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetPlane(
        pPlaneArray: *mut cudaArray_t,
        hArray: cudaArray_t,
        planeIdx: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetMemoryRequirements(
        memoryRequirements: *mut cudaArrayMemoryRequirements,
        array: cudaArray_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMipmappedArrayGetMemoryRequirements(
        memoryRequirements: *mut cudaArrayMemoryRequirements,
        mipmap: cudaMipmappedArray_t,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaArrayGetSparseProperties(
        sparseProperties: *mut cudaArraySparseProperties,
        array: cudaArray_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMipmappedArrayGetSparseProperties(
        sparseProperties: *mut cudaArraySparseProperties,
        mipmap: cudaMipmappedArray_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyPeer(
        dst: *mut ::std::os::raw::c_void,
        dstDevice: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        count: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2D(
        dst: *mut ::std::os::raw::c_void,
        dpitch: size_t,
        src: *const ::std::os::raw::c_void,
        spitch: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DToArray(
        dst: cudaArray_t,
        wOffset: size_t,
        hOffset: size_t,
        src: *const ::std::os::raw::c_void,
        spitch: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DFromArray(
        dst: *mut ::std::os::raw::c_void,
        dpitch: size_t,
        src: cudaArray_const_t,
        wOffset: size_t,
        hOffset: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DArrayToArray(
        dst: cudaArray_t,
        wOffsetDst: size_t,
        hOffsetDst: size_t,
        src: cudaArray_const_t,
        wOffsetSrc: size_t,
        hOffsetSrc: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToSymbol(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromSymbol(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyAsync(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyPeerAsync(
        dst: *mut ::std::os::raw::c_void,
        dstDevice: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        srcDevice: ::std::os::raw::c_int,
        count: size_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: size_t,
        src: *const ::std::os::raw::c_void,
        spitch: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DToArrayAsync(
        dst: cudaArray_t,
        wOffset: size_t,
        hOffset: size_t,
        src: *const ::std::os::raw::c_void,
        spitch: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpy2DFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        dpitch: size_t,
        src: cudaArray_const_t,
        wOffset: size_t,
        hOffset: size_t,
        width: size_t,
        height: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToSymbolAsync(
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromSymbolAsync(
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset(
        devPtr: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        count: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset2D(
        devPtr: *mut ::std::os::raw::c_void,
        pitch: size_t,
        value: ::std::os::raw::c_int,
        width: size_t,
        height: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset3D(
        pitchedDevPtr: cudaPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: cudaExtent,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemsetAsync(
        devPtr: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_int,
        count: size_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset2DAsync(
        devPtr: *mut ::std::os::raw::c_void,
        pitch: size_t,
        value: ::std::os::raw::c_int,
        width: size_t,
        height: size_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemset3DAsync(
        pitchedDevPtr: cudaPitchedPtr,
        value: ::std::os::raw::c_int,
        extent: cudaExtent,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSymbolAddress(
        devPtr: *mut *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSymbolSize(
        size: *mut size_t,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPrefetchAsync(
        devPtr: *const ::std::os::raw::c_void,
        count: size_t,
        dstDevice: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemAdvise(
        devPtr: *const ::std::os::raw::c_void,
        count: size_t,
        advice: cudaMemoryAdvise,
        device: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        dataSize: size_t,
        attribute: cudaMemRangeAttribute,
        devPtr: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        dataSizes: *mut size_t,
        attributes: *mut cudaMemRangeAttribute,
        numAttributes: size_t,
        devPtr: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToArray(
        dst: cudaArray_t,
        wOffset: size_t,
        hOffset: size_t,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromArray(
        dst: *mut ::std::os::raw::c_void,
        src: cudaArray_const_t,
        wOffset: size_t,
        hOffset: size_t,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyArrayToArray(
        dst: cudaArray_t,
        wOffsetDst: size_t,
        hOffsetDst: size_t,
        src: cudaArray_const_t,
        wOffsetSrc: size_t,
        hOffsetSrc: size_t,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyToArrayAsync(
        dst: cudaArray_t,
        wOffset: size_t,
        hOffset: size_t,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemcpyFromArrayAsync(
        dst: *mut ::std::os::raw::c_void,
        src: cudaArray_const_t,
        wOffset: size_t,
        hOffset: size_t,
        count: size_t,
        kind: cudaMemcpyKind,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocAsync(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        hStream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaFreeAsync(devPtr: *mut ::std::os::raw::c_void, hStream: cudaStream_t)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolTrimTo(memPool: cudaMemPool_t, minBytesToKeep: size_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolSetAttribute(
        memPool: cudaMemPool_t,
        attr: cudaMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolGetAttribute(
        memPool: cudaMemPool_t,
        attr: cudaMemPoolAttr,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolSetAccess(
        memPool: cudaMemPool_t,
        descList: *const cudaMemAccessDesc,
        count: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolGetAccess(
        flags: *mut cudaMemAccessFlags,
        memPool: cudaMemPool_t,
        location: *mut cudaMemLocation,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolCreate(
        memPool: *mut cudaMemPool_t,
        poolProps: *const cudaMemPoolProps,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolDestroy(memPool: cudaMemPool_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaMallocFromPoolAsync(
        ptr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        memPool: cudaMemPool_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        memPool: cudaMemPool_t,
        handleType: cudaMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolImportFromShareableHandle(
        memPool: *mut cudaMemPool_t,
        shareableHandle: *mut ::std::os::raw::c_void,
        handleType: cudaMemAllocationHandleType,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolExportPointer(
        exportData: *mut cudaMemPoolPtrExportData,
        ptr: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaMemPoolImportPointer(
        ptr: *mut *mut ::std::os::raw::c_void,
        memPool: cudaMemPool_t,
        exportData: *mut cudaMemPoolPtrExportData,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaPointerGetAttributes(
        attributes: *mut cudaPointerAttributes,
        ptr: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
        peerDevice: ::std::os::raw::c_int,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceEnablePeerAccess(
        peerDevice: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceDisablePeerAccess(peerDevice: ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsUnregisterResource(resource: cudaGraphicsResource_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsResourceSetMapFlags(
        resource: cudaGraphicsResource_t,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsMapResources(
        count: ::std::os::raw::c_int,
        resources: *mut cudaGraphicsResource_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsUnmapResources(
        count: ::std::os::raw::c_int,
        resources: *mut cudaGraphicsResource_t,
        stream: cudaStream_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsResourceGetMappedPointer(
        devPtr: *mut *mut ::std::os::raw::c_void,
        size: *mut size_t,
        resource: cudaGraphicsResource_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsSubResourceGetMappedArray(
        array: *mut cudaArray_t,
        resource: cudaGraphicsResource_t,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphicsResourceGetMappedMipmappedArray(
        mipmappedArray: *mut cudaMipmappedArray_t,
        resource: cudaGraphicsResource_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaBindTexture(
        offset: *mut size_t,
        texref: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const cudaChannelFormatDesc,
        size: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaBindTexture2D(
        offset: *mut size_t,
        texref: *const textureReference,
        devPtr: *const ::std::os::raw::c_void,
        desc: *const cudaChannelFormatDesc,
        width: size_t,
        height: size_t,
        pitch: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaBindTextureToArray(
        texref: *const textureReference,
        array: cudaArray_const_t,
        desc: *const cudaChannelFormatDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaBindTextureToMipmappedArray(
        texref: *const textureReference,
        mipmappedArray: cudaMipmappedArray_const_t,
        desc: *const cudaChannelFormatDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaUnbindTexture(texref: *const textureReference) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureAlignmentOffset(
        offset: *mut size_t,
        texref: *const textureReference,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureReference(
        texref: *mut *const textureReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaBindSurfaceToArray(
        surfref: *const surfaceReference,
        array: cudaArray_const_t,
        desc: *const cudaChannelFormatDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSurfaceReference(
        surfref: *mut *const surfaceReference,
        symbol: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetChannelDesc(
        desc: *mut cudaChannelFormatDesc,
        array: cudaArray_const_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaCreateChannelDesc(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        f: cudaChannelFormatKind,
    ) -> cudaChannelFormatDesc;
}
extern "C" {
    pub fn cudaCreateTextureObject(
        pTexObject: *mut cudaTextureObject_t,
        pResDesc: *const cudaResourceDesc,
        pTexDesc: *const cudaTextureDesc,
        pResViewDesc: *const cudaResourceViewDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroyTextureObject(texObject: cudaTextureObject_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureObjectResourceDesc(
        pResDesc: *mut cudaResourceDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureObjectTextureDesc(
        pTexDesc: *mut cudaTextureDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut cudaResourceViewDesc,
        texObject: cudaTextureObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaCreateSurfaceObject(
        pSurfObject: *mut cudaSurfaceObject_t,
        pResDesc: *const cudaResourceDesc,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDestroySurfaceObject(surfObject: cudaSurfaceObject_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetSurfaceObjectResourceDesc(
        pResDesc: *mut cudaResourceDesc,
        surfObject: cudaSurfaceObject_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaRuntimeGetVersion(runtimeVersion: *mut ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphCreate(pGraph: *mut cudaGraph_t, flags: ::std::os::raw::c_uint) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddKernelNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeCopyAttributes(
        hSrc: cudaGraphNode_t,
        hDst: cudaGraphNode_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeGetAttribute(
        hNode: cudaGraphNode_t,
        attr: cudaKernelNodeAttrID,
        value_out: *mut cudaKernelNodeAttrValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphKernelNodeSetAttribute(
        hNode: cudaGraphNode_t,
        attr: cudaKernelNodeAttrID,
        value: *const cudaKernelNodeAttrValue,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        pCopyParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNodeToSymbol(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNodeFromSymbol(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemcpyNode1D(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParamsToSymbol(
        node: cudaGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParamsFromSymbol(
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemcpyNodeSetParams1D(
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemsetNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        pMemsetParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemsetNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemsetNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddHostNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphHostNodeGetParams(
        node: cudaGraphNode_t,
        pNodeParams: *mut cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphHostNodeSetParams(
        node: cudaGraphNode_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddChildGraphNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        childGraph: cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphChildGraphNodeGetGraph(
        node: cudaGraphNode_t,
        pGraph: *mut cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddEmptyNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddEventRecordNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventRecordNodeGetEvent(
        node: cudaGraphNode_t,
        event_out: *mut cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventRecordNodeSetEvent(
        node: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddEventWaitNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventWaitNodeGetEvent(
        node: cudaGraphNode_t,
        event_out: *mut cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphEventWaitNodeSetEvent(node: cudaGraphNode_t, event: cudaEvent_t)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddExternalSemaphoresSignalNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresSignalNodeGetParams(
        hNode: cudaGraphNode_t,
        params_out: *mut cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresSignalNodeSetParams(
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddExternalSemaphoresWaitNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresWaitNodeGetParams(
        hNode: cudaGraphNode_t,
        params_out: *mut cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExternalSemaphoresWaitNodeSetParams(
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemAllocNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        nodeParams: *mut cudaMemAllocNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemAllocNodeGetParams(
        node: cudaGraphNode_t,
        params_out: *mut cudaMemAllocNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddMemFreeNode(
        pGraphNode: *mut cudaGraphNode_t,
        graph: cudaGraph_t,
        pDependencies: *const cudaGraphNode_t,
        numDependencies: size_t,
        dptr: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphMemFreeNodeGetParams(
        node: cudaGraphNode_t,
        dptr_out: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGraphMemTrim(device: ::std::os::raw::c_int) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceGetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: cudaGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaDeviceSetGraphMemAttribute(
        device: ::std::os::raw::c_int,
        attr: cudaGraphMemAttributeType,
        value: *mut ::std::os::raw::c_void,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphClone(pGraphClone: *mut cudaGraph_t, originalGraph: cudaGraph_t)
        -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeFindInClone(
        pNode: *mut cudaGraphNode_t,
        originalNode: cudaGraphNode_t,
        clonedGraph: cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetType(
        node: cudaGraphNode_t,
        pType: *mut cudaGraphNodeType,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphGetNodes(
        graph: cudaGraph_t,
        nodes: *mut cudaGraphNode_t,
        numNodes: *mut size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphGetRootNodes(
        graph: cudaGraph_t,
        pRootNodes: *mut cudaGraphNode_t,
        pNumRootNodes: *mut size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphGetEdges(
        graph: cudaGraph_t,
        from: *mut cudaGraphNode_t,
        to: *mut cudaGraphNode_t,
        numEdges: *mut size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetDependencies(
        node: cudaGraphNode_t,
        pDependencies: *mut cudaGraphNode_t,
        pNumDependencies: *mut size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetDependentNodes(
        node: cudaGraphNode_t,
        pDependentNodes: *mut cudaGraphNode_t,
        pNumDependentNodes: *mut size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphAddDependencies(
        graph: cudaGraph_t,
        from: *const cudaGraphNode_t,
        to: *const cudaGraphNode_t,
        numDependencies: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphRemoveDependencies(
        graph: cudaGraph_t,
        from: *const cudaGraphNode_t,
        to: *const cudaGraphNode_t,
        numDependencies: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphDestroyNode(node: cudaGraphNode_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphInstantiate(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        pErrorNode: *mut cudaGraphNode_t,
        pLogBuffer: *mut ::std::os::raw::c_char,
        bufferSize: size_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphInstantiateWithFlags(
        pGraphExec: *mut cudaGraphExec_t,
        graph: cudaGraph_t,
        flags: ::std::os::raw::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecKernelNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaKernelNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemcpy3DParms,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParamsToSymbol(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        symbol: *const ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParamsFromSymbol(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        symbol: *const ::std::os::raw::c_void,
        count: size_t,
        offset: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemcpyNodeSetParams1D(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        kind: cudaMemcpyKind,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecMemsetNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaMemsetParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecHostNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        pNodeParams: *const cudaHostNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecChildGraphNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        node: cudaGraphNode_t,
        childGraph: cudaGraph_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecEventRecordNodeSetEvent(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecEventWaitNodeSetEvent(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        event: cudaEvent_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreSignalNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        nodeParams: *const cudaExternalSemaphoreWaitNodeParams,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeSetEnabled(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        isEnabled: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphNodeGetEnabled(
        hGraphExec: cudaGraphExec_t,
        hNode: cudaGraphNode_t,
        isEnabled: *mut ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecUpdate(
        hGraphExec: cudaGraphExec_t,
        hGraph: cudaGraph_t,
        hErrorNode_out: *mut cudaGraphNode_t,
        updateResult_out: *mut cudaGraphExecUpdateResult,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphUpload(graphExec: cudaGraphExec_t, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphLaunch(graphExec: cudaGraphExec_t, stream: cudaStream_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphExecDestroy(graphExec: cudaGraphExec_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphDestroy(graph: cudaGraph_t) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphDebugDotPrint(
        graph: cudaGraph_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaUserObjectCreate(
        object_out: *mut cudaUserObject_t,
        ptr: *mut ::std::os::raw::c_void,
        destroy: cudaHostFn_t,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaUserObjectRetain(
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaUserObjectRelease(
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphRetainUserObject(
        graph: cudaGraph_t,
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGraphReleaseUserObject(
        graph: cudaGraph_t,
        object: cudaUserObject_t,
        count: ::std::os::raw::c_uint,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetDriverEntryPoint(
        symbol: *const ::std::os::raw::c_char,
        funcPtr: *mut *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulonglong,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetExportTable(
        ppExportTable: *mut *const ::std::os::raw::c_void,
        pExportTableId: *const cudaUUID_t,
    ) -> cudaError_t;
}
extern "C" {
    pub fn cudaGetFuncBySymbol(
        functionPtr: *mut cudaFunction_t,
        symbolPtr: *const ::std::os::raw::c_void,
    ) -> cudaError_t;
}
pub const nvrtcResult_NVRTC_SUCCESS: nvrtcResult = 0;
pub const nvrtcResult_NVRTC_ERROR_OUT_OF_MEMORY: nvrtcResult = 1;
pub const nvrtcResult_NVRTC_ERROR_PROGRAM_CREATION_FAILURE: nvrtcResult = 2;
pub const nvrtcResult_NVRTC_ERROR_INVALID_INPUT: nvrtcResult = 3;
pub const nvrtcResult_NVRTC_ERROR_INVALID_PROGRAM: nvrtcResult = 4;
pub const nvrtcResult_NVRTC_ERROR_INVALID_OPTION: nvrtcResult = 5;
pub const nvrtcResult_NVRTC_ERROR_COMPILATION: nvrtcResult = 6;
pub const nvrtcResult_NVRTC_ERROR_BUILTIN_OPERATION_FAILURE: nvrtcResult = 7;
pub const nvrtcResult_NVRTC_ERROR_NO_NAME_EXPRESSIONS_AFTER_COMPILATION: nvrtcResult = 8;
pub const nvrtcResult_NVRTC_ERROR_NO_LOWERED_NAMES_BEFORE_COMPILATION: nvrtcResult = 9;
pub const nvrtcResult_NVRTC_ERROR_NAME_EXPRESSION_NOT_VALID: nvrtcResult = 10;
pub const nvrtcResult_NVRTC_ERROR_INTERNAL_ERROR: nvrtcResult = 11;
pub type nvrtcResult = ::std::os::raw::c_uint;
extern "C" {
    pub fn nvrtcGetErrorString(result: nvrtcResult) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvrtcVersion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
    ) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetNumSupportedArchs(numArchs: *mut ::std::os::raw::c_int) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetSupportedArchs(supportedArchs: *mut ::std::os::raw::c_int) -> nvrtcResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _nvrtcProgram {
    _unused: [u8; 0],
}
pub type nvrtcProgram = *mut _nvrtcProgram;
extern "C" {
    pub fn nvrtcCreateProgram(
        prog: *mut nvrtcProgram,
        src: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        numHeaders: ::std::os::raw::c_int,
        headers: *const *const ::std::os::raw::c_char,
        includeNames: *const *const ::std::os::raw::c_char,
    ) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcDestroyProgram(prog: *mut nvrtcProgram) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcCompileProgram(
        prog: nvrtcProgram,
        numOptions: ::std::os::raw::c_int,
        options: *const *const ::std::os::raw::c_char,
    ) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetPTXSize(prog: nvrtcProgram, ptxSizeRet: *mut size_t) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetPTX(prog: nvrtcProgram, ptx: *mut ::std::os::raw::c_char) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetCUBINSize(prog: nvrtcProgram, cubinSizeRet: *mut size_t) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetCUBIN(prog: nvrtcProgram, cubin: *mut ::std::os::raw::c_char) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetNVVMSize(prog: nvrtcProgram, nvvmSizeRet: *mut size_t) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetNVVM(prog: nvrtcProgram, nvvm: *mut ::std::os::raw::c_char) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetProgramLogSize(prog: nvrtcProgram, logSizeRet: *mut size_t) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetProgramLog(prog: nvrtcProgram, log: *mut ::std::os::raw::c_char) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcAddNameExpression(
        prog: nvrtcProgram,
        name_expression: *const ::std::os::raw::c_char,
    ) -> nvrtcResult;
}
extern "C" {
    pub fn nvrtcGetLoweredName(
        prog: nvrtcProgram,
        name_expression: *const ::std::os::raw::c_char,
        lowered_name: *mut *const ::std::os::raw::c_char,
    ) -> nvrtcResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futhark_context_config {
    _unused: [u8; 0],
}
extern "C" {
    pub fn futhark_context_config_new() -> *mut futhark_context_config;
}
extern "C" {
    pub fn futhark_context_config_free(cfg: *mut futhark_context_config);
}
extern "C" {
    pub fn futhark_context_config_add_nvrtc_option(
        cfg: *mut futhark_context_config,
        opt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_config_set_debugging(
        cfg: *mut futhark_context_config,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_profiling(
        cfg: *mut futhark_context_config,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_logging(
        cfg: *mut futhark_context_config,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_device(
        cfg: *mut futhark_context_config,
        s: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_config_dump_program_to(
        cfg: *mut futhark_context_config,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_config_load_program_from(
        cfg: *mut futhark_context_config,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_config_dump_ptx_to(
        cfg: *mut futhark_context_config,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_config_load_ptx_from(
        cfg: *mut futhark_context_config,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_config_set_default_group_size(
        cfg: *mut futhark_context_config,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_default_num_groups(
        cfg: *mut futhark_context_config,
        num: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_default_tile_size(
        cfg: *mut futhark_context_config,
        num: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_default_reg_tile_size(
        cfg: *mut futhark_context_config,
        num: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_default_threshold(
        cfg: *mut futhark_context_config,
        num: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn futhark_context_config_set_tuning_param(
        cfg: *mut futhark_context_config,
        param_name: *const ::std::os::raw::c_char,
        new_value: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futhark_context {
    _unused: [u8; 0],
}
extern "C" {
    pub fn futhark_context_new(cfg: *mut futhark_context_config) -> *mut futhark_context;
}
extern "C" {
    pub fn futhark_context_free(ctx: *mut futhark_context);
}
extern "C" {
    pub fn futhark_get_tuning_param_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_get_tuning_param_name(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn futhark_get_tuning_param_class(
        arg1: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futhark_i32_2d {
    _unused: [u8; 0],
}
extern "C" {
    pub fn futhark_new_i32_2d(
        ctx: *mut futhark_context,
        data: *const i32,
        dim0: i64,
        dim1: i64,
    ) -> *mut futhark_i32_2d;
}
extern "C" {
    pub fn futhark_new_raw_i32_2d(
        ctx: *mut futhark_context,
        data: CUdeviceptr,
        offset: i64,
        dim0: i64,
        dim1: i64,
    ) -> *mut futhark_i32_2d;
}
extern "C" {
    pub fn futhark_free_i32_2d(
        ctx: *mut futhark_context,
        arr: *mut futhark_i32_2d,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_values_i32_2d(
        ctx: *mut futhark_context,
        arr: *mut futhark_i32_2d,
        data: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_values_raw_i32_2d(
        ctx: *mut futhark_context,
        arr: *mut futhark_i32_2d,
    ) -> CUdeviceptr;
}
extern "C" {
    pub fn futhark_shape_i32_2d(ctx: *mut futhark_context, arr: *mut futhark_i32_2d) -> *const i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futhark_u64_2d {
    _unused: [u8; 0],
}
extern "C" {
    pub fn futhark_new_u64_2d(
        ctx: *mut futhark_context,
        data: *const u64,
        dim0: i64,
        dim1: i64,
    ) -> *mut futhark_u64_2d;
}
extern "C" {
    pub fn futhark_new_raw_u64_2d(
        ctx: *mut futhark_context,
        data: CUdeviceptr,
        offset: i64,
        dim0: i64,
        dim1: i64,
    ) -> *mut futhark_u64_2d;
}
extern "C" {
    pub fn futhark_free_u64_2d(
        ctx: *mut futhark_context,
        arr: *mut futhark_u64_2d,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_values_u64_2d(
        ctx: *mut futhark_context,
        arr: *mut futhark_u64_2d,
        data: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_values_raw_u64_2d(
        ctx: *mut futhark_context,
        arr: *mut futhark_u64_2d,
    ) -> CUdeviceptr;
}
extern "C" {
    pub fn futhark_shape_u64_2d(ctx: *mut futhark_context, arr: *mut futhark_u64_2d) -> *const i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futhark_u64_3d {
    _unused: [u8; 0],
}
extern "C" {
    pub fn futhark_new_u64_3d(
        ctx: *mut futhark_context,
        data: *const u64,
        dim0: i64,
        dim1: i64,
        dim2: i64,
    ) -> *mut futhark_u64_3d;
}
extern "C" {
    pub fn futhark_new_raw_u64_3d(
        ctx: *mut futhark_context,
        data: CUdeviceptr,
        offset: i64,
        dim0: i64,
        dim1: i64,
        dim2: i64,
    ) -> *mut futhark_u64_3d;
}
extern "C" {
    pub fn futhark_free_u64_3d(
        ctx: *mut futhark_context,
        arr: *mut futhark_u64_3d,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_values_u64_3d(
        ctx: *mut futhark_context,
        arr: *mut futhark_u64_3d,
        data: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_values_raw_u64_3d(
        ctx: *mut futhark_context,
        arr: *mut futhark_u64_3d,
    ) -> CUdeviceptr;
}
extern "C" {
    pub fn futhark_shape_u64_3d(ctx: *mut futhark_context, arr: *mut futhark_u64_3d) -> *const i64;
}
extern "C" {
    pub fn futhark_entry_make_transposed_quotient_codewords_non_opaque(
        ctx: *mut futhark_context,
        out0: *mut *mut futhark_u64_3d,
        in0: *const futhark_u64_2d,
        in1: *const futhark_u64_3d,
        in2: *const futhark_u64_3d,
        in3: *const futhark_u64_3d,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_entry_matmul(
        ctx: *mut futhark_context,
        out0: *mut *mut futhark_i32_2d,
        in0: *const futhark_i32_2d,
        in1: *const futhark_i32_2d,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_context_sync(ctx: *mut futhark_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futhark_context_config_set_cache_file(
        cfg: *mut futhark_context_config,
        f: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn futhark_context_report(ctx: *mut futhark_context) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn futhark_context_get_error(ctx: *mut futhark_context) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn futhark_context_set_logging_file(ctx: *mut futhark_context, f: *mut FILE);
}
extern "C" {
    pub fn futhark_context_pause_profiling(ctx: *mut futhark_context);
}
extern "C" {
    pub fn futhark_context_unpause_profiling(ctx: *mut futhark_context);
}
extern "C" {
    pub fn futhark_context_clear_caches(ctx: *mut futhark_context) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
